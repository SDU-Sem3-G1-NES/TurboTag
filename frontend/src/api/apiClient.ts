//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ApiConfiguration {
  public baseUrl: string
  public instance: AxiosInstance

  constructor(baseUrl: string = 'https://localhost:7275', instance?: AxiosInstance) {
    this.baseUrl = baseUrl
    this.instance =
      instance ||
      axios.create({
        baseURL: baseUrl,
        headers: {
          'Content-Type': 'application/json'
        }
      })

    this.instance.interceptors.request.use(
      (config) => {
        // Add auth token if needed
        // const token = localStorage.getItem("authToken");
        // if (token) config.headers.Authorization = `Bearer ${token}`;
        return config
      },
      (error) => Promise.reject(error)
    )
  }
}

export class BaseApiClient {
  protected instance: AxiosInstance
  protected baseUrl: string

  constructor(configuration: ApiConfiguration) {
    this.baseUrl = configuration.baseUrl
    this.instance = configuration.instance
  }
}

export interface IAdminClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            getAllUsers(body?: UserFilter | undefined): Promise<PagedResult<UserDto> | UserDto[]>                    /**
             * @param email (optional) 
             * @return OK
             */
            getUserByEmail(email?: string | undefined): Promise<UserDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            createNewUser(body?: UserDtoUserCredentialsDtoValueTuple | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUserById(body?: UserDto | undefined): Promise<void>                    /**
             * @param userId (optional) 
             * @return OK
             */
            deleteUserById(userId?: number | undefined): Promise<void>        }

    export class AdminClient extends BaseApiClient implements IAdminClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getAllUsers(body?: UserFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<UserDto> | UserDto[]> {        let url_ = this.baseUrl + "/Admin/GetAllUsers";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllUsers(_response);
                });
        }

    protected processGetAllUsers(response: AxiosResponse): Promise<PagedResult<UserDto> | UserDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UserDto.fromJS(item));
        } else if (isPagedResult<UserDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UserDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UserDto> | UserDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UserDto> | UserDto[]>(null as any);
}
    

        /**
         * @param email (optional) 
         * @return OK
         */
        getUserByEmail(email?: string | undefined, cancelToken?: CancelToken): Promise<UserDto> {        let url_ = this.baseUrl + "/Admin/GetUserByEmail?";
if (email === null)
    throw new Error("The parameter 'email' cannot be null.");
else if (email !== undefined)
    url_ += "email=" + encodeURIComponent("" + email) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserByEmail(_response);
                });
        }

    protected processGetUserByEmail(response: AxiosResponse): Promise<UserDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = UserDto.fromJS(resultData200);
        
        return Promise.resolve<UserDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<UserDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        createNewUser(body?: UserDtoUserCredentialsDtoValueTuple | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Admin/CreateNewUser";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCreateNewUser(_response);
                });
        }

    protected processCreateNewUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUserById(body?: UserDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Admin/UpdateUserById";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUserById(_response);
                });
        }

    protected processUpdateUserById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param userId (optional) 
         * @return OK
         */
        deleteUserById(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Admin/DeleteUserById?";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteUserById(_response);
                });
        }

    protected processDeleteUserById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface IContentLibraryClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            getAllLibraries(body?: LibraryFilter | undefined): Promise<PagedResult<LibraryDto> | LibraryDto[]>                    /**
             * @param body (optional) 
             * @return OK
             */
            getUserLibraries(body?: UserDtoLibraryFilterValueTuple | undefined): Promise<PagedResult<LibraryDto> | LibraryDto[]>                    /**
             * @param libraryId (optional) 
             * @return OK
             */
            getLibraryById(libraryId?: number | undefined): Promise<LibraryDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            createNewLibrary(body?: LibraryDto | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateLibraryById(body?: LibraryDto | undefined): Promise<void>                    /**
             * @param libraryId (optional) 
             * @return OK
             */
            deleteLibraryById(libraryId?: number | undefined): Promise<void>        }

    export class ContentLibraryClient extends BaseApiClient implements IContentLibraryClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getAllLibraries(body?: LibraryFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<LibraryDto> | LibraryDto[]> {        let url_ = this.baseUrl + "/ContentLibrary/GetAllLibraries";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllLibraries(_response);
                });
        }

    protected processGetAllLibraries(response: AxiosResponse): Promise<PagedResult<LibraryDto> | LibraryDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(LibraryDto.fromJS(item));
        } else if (isPagedResult<LibraryDto>(resultData200)) {
            result200 = resultData200 as PagedResult<LibraryDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<LibraryDto> | LibraryDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<LibraryDto> | LibraryDto[]>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getUserLibraries(body?: UserDtoLibraryFilterValueTuple | undefined, cancelToken?: CancelToken): Promise<PagedResult<LibraryDto> | LibraryDto[]> {        let url_ = this.baseUrl + "/ContentLibrary/GetUserLibraries";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserLibraries(_response);
                });
        }

    protected processGetUserLibraries(response: AxiosResponse): Promise<PagedResult<LibraryDto> | LibraryDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(LibraryDto.fromJS(item));
        } else if (isPagedResult<LibraryDto>(resultData200)) {
            result200 = resultData200 as PagedResult<LibraryDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<LibraryDto> | LibraryDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<LibraryDto> | LibraryDto[]>(null as any);
}
    

        /**
         * @param libraryId (optional) 
         * @return OK
         */
        getLibraryById(libraryId?: number | undefined, cancelToken?: CancelToken): Promise<LibraryDto> {        let url_ = this.baseUrl + "/ContentLibrary/GetLibraryById?";
if (libraryId === null)
    throw new Error("The parameter 'libraryId' cannot be null.");
else if (libraryId !== undefined)
    url_ += "libraryId=" + encodeURIComponent("" + libraryId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLibraryById(_response);
                });
        }

    protected processGetLibraryById(response: AxiosResponse): Promise<LibraryDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = LibraryDto.fromJS(resultData200);
        
        return Promise.resolve<LibraryDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<LibraryDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        createNewLibrary(body?: LibraryDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/ContentLibrary/CreateNewLibrary";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCreateNewLibrary(_response);
                });
        }

    protected processCreateNewLibrary(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateLibraryById(body?: LibraryDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/ContentLibrary/UpdateLibraryById";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateLibraryById(_response);
                });
        }

    protected processUpdateLibraryById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param libraryId (optional) 
         * @return OK
         */
        deleteLibraryById(libraryId?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/ContentLibrary/DeleteLibraryById?";
if (libraryId === null)
    throw new Error("The parameter 'libraryId' cannot be null.");
else if (libraryId !== undefined)
    url_ += "libraryId=" + encodeURIComponent("" + libraryId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteLibraryById(_response);
                });
        }

    protected processDeleteLibraryById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface ILoginClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            validateUserCredentials(body?: UserCredentialsDto | undefined): Promise<boolean>                    /**
             * @param email (optional) 
             * @return OK
             */
            getUserDataByEmail(email?: string | undefined): Promise<UserDto>        }

    export class LoginClient extends BaseApiClient implements ILoginClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        validateUserCredentials(body?: UserCredentialsDto | undefined, cancelToken?: CancelToken): Promise<boolean> {        let url_ = this.baseUrl + "/Login/ValidateUserCredentials";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "GET",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processValidateUserCredentials(_response);
                });
        }

    protected processValidateUserCredentials(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = resultData200 as boolean;
        
        return Promise.resolve<boolean>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}
    

        /**
         * @param email (optional) 
         * @return OK
         */
        getUserDataByEmail(email?: string | undefined, cancelToken?: CancelToken): Promise<UserDto> {        let url_ = this.baseUrl + "/Login/GetUserDataByEmail?";
if (email === null)
    throw new Error("The parameter 'email' cannot be null.");
else if (email !== undefined)
    url_ += "email=" + encodeURIComponent("" + email) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserDataByEmail(_response);
                });
        }

    protected processGetUserDataByEmail(response: AxiosResponse): Promise<UserDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = UserDto.fromJS(resultData200);
        
        return Promise.resolve<UserDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<UserDto>(null as any);
}
        }

            export interface IRegisterClient {
                    /**
             * @param email (optional) 
             * @return OK
             */
            checkIfUserExistsByEmail(email?: string | undefined): Promise<boolean>        }

    export class RegisterClient extends BaseApiClient implements IRegisterClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param email (optional) 
         * @return OK
         */
        checkIfUserExistsByEmail(email?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {        let url_ = this.baseUrl + "/Register/CheckIfUserExistsByEmail?";
if (email === null)
    throw new Error("The parameter 'email' cannot be null.");
else if (email !== undefined)
    url_ += "email=" + encodeURIComponent("" + email) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCheckIfUserExistsByEmail(_response);
                });
        }

    protected processCheckIfUserExistsByEmail(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = resultData200 as boolean;
        
        return Promise.resolve<boolean>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}
        }

            export interface ISettingsClient {
                    /**
             * @return OK
             */
            getAllSettings(): Promise<PagedResult<SettingsDto> | SettingsDto[]>                    /**
             * @param settingId (optional) 
             * @return OK
             */
            getSettingById(settingId?: number | undefined): Promise<SettingsDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            addSetting(body?: SettingsDto | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateSetting(body?: SettingsDto | undefined): Promise<void>                    /**
             * @param settingId (optional) 
             * @return OK
             */
            deleteSettingById(settingId?: number | undefined): Promise<void>        }

    export class SettingsClient extends BaseApiClient implements ISettingsClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @return OK
         */
        getAllSettings( cancelToken?: CancelToken): Promise<PagedResult<SettingsDto> | SettingsDto[]> {        let url_ = this.baseUrl + "/Settings/GetAllSettings";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllSettings(_response);
                });
        }

    protected processGetAllSettings(response: AxiosResponse): Promise<PagedResult<SettingsDto> | SettingsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(SettingsDto.fromJS(item));
        } else if (isPagedResult<SettingsDto>(resultData200)) {
            result200 = resultData200 as PagedResult<SettingsDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<SettingsDto> | SettingsDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<SettingsDto> | SettingsDto[]>(null as any);
}
    

        /**
         * @param settingId (optional) 
         * @return OK
         */
        getSettingById(settingId?: number | undefined, cancelToken?: CancelToken): Promise<SettingsDto> {        let url_ = this.baseUrl + "/Settings/GetSettingById?";
if (settingId === null)
    throw new Error("The parameter 'settingId' cannot be null.");
else if (settingId !== undefined)
    url_ += "settingId=" + encodeURIComponent("" + settingId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetSettingById(_response);
                });
        }

    protected processGetSettingById(response: AxiosResponse): Promise<SettingsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = SettingsDto.fromJS(resultData200);
        
        return Promise.resolve<SettingsDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<SettingsDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        addSetting(body?: SettingsDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Settings/AddSetting";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processAddSetting(_response);
                });
        }

    protected processAddSetting(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateSetting(body?: SettingsDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Settings/UpdateSetting";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateSetting(_response);
                });
        }

    protected processUpdateSetting(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param settingId (optional) 
         * @return OK
         */
        deleteSettingById(settingId?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Settings/DeleteSettingById?";
if (settingId === null)
    throw new Error("The parameter 'settingId' cannot be null.");
else if (settingId !== undefined)
    url_ += "settingId=" + encodeURIComponent("" + settingId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteSettingById(_response);
                });
        }

    protected processDeleteSettingById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface ITestClient {
                    /**
             * @return OK
             */
            get(): Promise<string>        }

    export class TestClient extends BaseApiClient implements ITestClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @return OK
         */
        get( cancelToken?: CancelToken): Promise<string> {        let url_ = this.baseUrl + "/Test";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGet(_response);
                });
        }

    protected processGet(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = resultData200 as string;
        
        return Promise.resolve<string>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}
        }

            export interface IUploadClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            getAllUploads(body?: UploadFilter | undefined): Promise<PagedResult<UploadDto> | UploadDto[]>                    /**
             * @param body (optional) 
             * @return OK
             */
            getUserUploads(body?: UserDtoUploadFilterValueTuple | undefined): Promise<PagedResult<UploadDto> | UploadDto[]>                    /**
             * @param libraryId (optional) 
             * @param body (optional) 
             * @return OK
             */
            getLibraryUploads(libraryId?: number | undefined, body?: UploadFilter | undefined): Promise<PagedResult<UploadDto> | UploadDto[]>                    /**
             * @param uploadId (optional) 
             * @return OK
             */
            getUploadById(uploadId?: number | undefined): Promise<UploadDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            addUpload(body?: UploadDto | undefined): Promise<number>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUpload(body?: UploadDto | undefined): Promise<void>                    /**
             * @param uploadId (optional) 
             * @return OK
             */
            deleteUploadById(uploadId?: number | undefined): Promise<void>        }

    export class UploadClient extends BaseApiClient implements IUploadClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getAllUploads(body?: UploadFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<UploadDto> | UploadDto[]> {        let url_ = this.baseUrl + "/Upload/GetAllUploads";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllUploads(_response);
                });
        }

    protected processGetAllUploads(response: AxiosResponse): Promise<PagedResult<UploadDto> | UploadDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UploadDto.fromJS(item));
        } else if (isPagedResult<UploadDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UploadDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getUserUploads(body?: UserDtoUploadFilterValueTuple | undefined, cancelToken?: CancelToken): Promise<PagedResult<UploadDto> | UploadDto[]> {        let url_ = this.baseUrl + "/Upload/GetUserUploads";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserUploads(_response);
                });
        }

    protected processGetUserUploads(response: AxiosResponse): Promise<PagedResult<UploadDto> | UploadDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UploadDto.fromJS(item));
        } else if (isPagedResult<UploadDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UploadDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(null as any);
}
    

        /**
         * @param libraryId (optional) 
         * @param body (optional) 
         * @return OK
         */
        getLibraryUploads(libraryId?: number | undefined, body?: UploadFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<UploadDto> | UploadDto[]> {        let url_ = this.baseUrl + "/Upload/GetLibraryUploads?";
if (libraryId === null)
    throw new Error("The parameter 'libraryId' cannot be null.");
else if (libraryId !== undefined)
    url_ += "libraryId=" + encodeURIComponent("" + libraryId) + "&";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLibraryUploads(_response);
                });
        }

    protected processGetLibraryUploads(response: AxiosResponse): Promise<PagedResult<UploadDto> | UploadDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UploadDto.fromJS(item));
        } else if (isPagedResult<UploadDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UploadDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(null as any);
}
    

        /**
         * @param uploadId (optional) 
         * @return OK
         */
        getUploadById(uploadId?: number | undefined, cancelToken?: CancelToken): Promise<UploadDto> {        let url_ = this.baseUrl + "/Upload/GetUploadById?";
if (uploadId === null)
    throw new Error("The parameter 'uploadId' cannot be null.");
else if (uploadId !== undefined)
    url_ += "uploadId=" + encodeURIComponent("" + uploadId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUploadById(_response);
                });
        }

    protected processGetUploadById(response: AxiosResponse): Promise<UploadDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = UploadDto.fromJS(resultData200);
        
        return Promise.resolve<UploadDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<UploadDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        addUpload(body?: UploadDto | undefined, cancelToken?: CancelToken): Promise<number> {        let url_ = this.baseUrl + "/Upload/AddUpload";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processAddUpload(_response);
                });
        }

    protected processAddUpload(response: AxiosResponse): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = resultData200 as number;
        
        return Promise.resolve<number>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<number>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUpload(body?: UploadDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Upload/UpdateUpload";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUpload(_response);
                });
        }

    protected processUpdateUpload(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param uploadId (optional) 
         * @return OK
         */
        deleteUploadById(uploadId?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Upload/DeleteUploadById?";
if (uploadId === null)
    throw new Error("The parameter 'uploadId' cannot be null.");
else if (uploadId !== undefined)
    url_ += "uploadId=" + encodeURIComponent("" + uploadId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteUploadById(_response);
                });
        }

    protected processDeleteUploadById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

export class LibraryDto implements ILibraryDto {
    id?: number;
    name?: string | null;

    constructor(data?: ILibraryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): LibraryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LibraryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ILibraryDto {
    id?: number;
    name?: string | null;
}

export class LibraryFilter implements ILibraryFilter {
    libraryIds?: number[] | null;
    libraryNames?: string[] | null;
    pageSize?: number | null;
    pageNumber?: number | null;

    constructor(data?: ILibraryFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["libraryIds"])) {
                this.libraryIds = [] as any;
                for (let item of _data["libraryIds"])
                    this.libraryIds!.push(item);
            }
            else {
                this.libraryIds = <any>null;
            }
            if (Array.isArray(_data["libraryNames"])) {
                this.libraryNames = [] as any;
                for (let item of _data["libraryNames"])
                    this.libraryNames!.push(item);
            }
            else {
                this.libraryNames = <any>null;
            }
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
        }
    }

    static fromJS(data: any): LibraryFilter {
        data = typeof data === 'object' ? data : {};
        let result = new LibraryFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.libraryIds)) {
            data["libraryIds"] = [];
            for (let item of this.libraryIds)
                data["libraryIds"].push(item);
        }
        if (Array.isArray(this.libraryNames)) {
            data["libraryNames"] = [];
            for (let item of this.libraryNames)
                data["libraryNames"].push(item);
        }
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        return data;
    }
}

export interface ILibraryFilter {
    libraryIds?: number[] | null;
    libraryNames?: string[] | null;
    pageSize?: number | null;
    pageNumber?: number | null;
}

export class PagedResult_LibraryDto implements IPagedResult_LibraryDto {
    items?: LibraryDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_LibraryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LibraryDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_LibraryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_LibraryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_LibraryDto {
    items?: LibraryDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_SettingsDto implements IPagedResult_SettingsDto {
    items?: SettingsDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_SettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SettingsDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_SettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_SettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_SettingsDto {
    items?: SettingsDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_UploadDto implements IPagedResult_UploadDto {
    items?: UploadDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_UploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UploadDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_UploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_UploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_UploadDto {
    items?: UploadDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_UserDto implements IPagedResult_UserDto {
    items?: UserDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_UserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_UserDto {
    items?: UserDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class SettingsDto implements ISettingsDto {
    id?: number;
    name?: string | null;
    value?: string | null;

    constructor(data?: ISettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): SettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface ISettingsDto {
    id?: number;
    name?: string | null;
    value?: string | null;
}

export class UploadDto implements IUploadDto {
    id?: number;
    ownerId?: number;
    date?: Date;
    type?: string | null;
    libraryId?: number;

    constructor(data?: IUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.libraryId = _data["libraryId"] !== undefined ? _data["libraryId"] : <any>null;
        }
    }

    static fromJS(data: any): UploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["libraryId"] = this.libraryId !== undefined ? this.libraryId : <any>null;
        return data;
    }
}

export interface IUploadDto {
    id?: number;
    ownerId?: number;
    date?: Date;
    type?: string | null;
    libraryId?: number;
}

export class UploadFilter implements IUploadFilter {
    uploadIds?: number[] | null;
    ownerIds?: number[] | null;
    libraryIds?: number[] | null;
    uploadTypes?: string[] | null;
    dateFrom?: Date | null;
    dateTo?: Date | null;
    pageNumber?: number | null;
    pageSize?: number | null;

    constructor(data?: IUploadFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["uploadIds"])) {
                this.uploadIds = [] as any;
                for (let item of _data["uploadIds"])
                    this.uploadIds!.push(item);
            }
            else {
                this.uploadIds = <any>null;
            }
            if (Array.isArray(_data["ownerIds"])) {
                this.ownerIds = [] as any;
                for (let item of _data["ownerIds"])
                    this.ownerIds!.push(item);
            }
            else {
                this.ownerIds = <any>null;
            }
            if (Array.isArray(_data["libraryIds"])) {
                this.libraryIds = [] as any;
                for (let item of _data["libraryIds"])
                    this.libraryIds!.push(item);
            }
            else {
                this.libraryIds = <any>null;
            }
            if (Array.isArray(_data["uploadTypes"])) {
                this.uploadTypes = [] as any;
                for (let item of _data["uploadTypes"])
                    this.uploadTypes!.push(item);
            }
            else {
                this.uploadTypes = <any>null;
            }
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>null;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
        }
    }

    static fromJS(data: any): UploadFilter {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.uploadIds)) {
            data["uploadIds"] = [];
            for (let item of this.uploadIds)
                data["uploadIds"].push(item);
        }
        if (Array.isArray(this.ownerIds)) {
            data["ownerIds"] = [];
            for (let item of this.ownerIds)
                data["ownerIds"].push(item);
        }
        if (Array.isArray(this.libraryIds)) {
            data["libraryIds"] = [];
            for (let item of this.libraryIds)
                data["libraryIds"].push(item);
        }
        if (Array.isArray(this.uploadTypes)) {
            data["uploadTypes"] = [];
            for (let item of this.uploadTypes)
                data["uploadTypes"].push(item);
        }
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        return data;
    }
}

export interface IUploadFilter {
    uploadIds?: number[] | null;
    ownerIds?: number[] | null;
    libraryIds?: number[] | null;
    uploadTypes?: string[] | null;
    dateFrom?: Date | null;
    dateTo?: Date | null;
    pageNumber?: number | null;
    pageSize?: number | null;
}

export class UserCredentialsDto implements IUserCredentialsDto {
    email?: string | null;
    password?: string | null;

    constructor(data?: IUserCredentialsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UserCredentialsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserCredentialsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IUserCredentialsDto {
    email?: string | null;
    password?: string | null;
}

export class UserDto implements IUserDto {
    id?: number;
    userTypeId?: number;
    name?: string | null;
    email?: string | null;
    accessibleLibraryIds?: number[] | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userTypeId = _data["userTypeId"] !== undefined ? _data["userTypeId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            if (Array.isArray(_data["accessibleLibraryIds"])) {
                this.accessibleLibraryIds = [] as any;
                for (let item of _data["accessibleLibraryIds"])
                    this.accessibleLibraryIds!.push(item);
            }
            else {
                this.accessibleLibraryIds = <any>null;
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userTypeId"] = this.userTypeId !== undefined ? this.userTypeId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        if (Array.isArray(this.accessibleLibraryIds)) {
            data["accessibleLibraryIds"] = [];
            for (let item of this.accessibleLibraryIds)
                data["accessibleLibraryIds"].push(item);
        }
        return data;
    }
}

export interface IUserDto {
    id?: number;
    userTypeId?: number;
    name?: string | null;
    email?: string | null;
    accessibleLibraryIds?: number[] | null;
}

export class UserDtoLibraryFilterValueTuple implements IUserDtoLibraryFilterValueTuple {

    constructor(data?: IUserDtoLibraryFilterValueTuple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): UserDtoLibraryFilterValueTuple {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoLibraryFilterValueTuple();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IUserDtoLibraryFilterValueTuple {
}

export class UserDtoUploadFilterValueTuple implements IUserDtoUploadFilterValueTuple {

    constructor(data?: IUserDtoUploadFilterValueTuple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): UserDtoUploadFilterValueTuple {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoUploadFilterValueTuple();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IUserDtoUploadFilterValueTuple {
}

export class UserDtoUserCredentialsDtoValueTuple implements IUserDtoUserCredentialsDtoValueTuple {

    constructor(data?: IUserDtoUserCredentialsDtoValueTuple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): UserDtoUserCredentialsDtoValueTuple {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoUserCredentialsDtoValueTuple();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IUserDtoUserCredentialsDtoValueTuple {
}

export class UserFilter implements IUserFilter {
    userIds?: number[] | null;
    userTypeIds?: number[] | null;
    name?: string | null;
    email?: string | null;
    libraryId?: number | null;
    pageNumber?: number | null;
    pageSize?: number | null;

    constructor(data?: IUserFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            else {
                this.userIds = <any>null;
            }
            if (Array.isArray(_data["userTypeIds"])) {
                this.userTypeIds = [] as any;
                for (let item of _data["userTypeIds"])
                    this.userTypeIds!.push(item);
            }
            else {
                this.userTypeIds = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.libraryId = _data["libraryId"] !== undefined ? _data["libraryId"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
        }
    }

    static fromJS(data: any): UserFilter {
        data = typeof data === 'object' ? data : {};
        let result = new UserFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        if (Array.isArray(this.userTypeIds)) {
            data["userTypeIds"] = [];
            for (let item of this.userTypeIds)
                data["userTypeIds"].push(item);
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["libraryId"] = this.libraryId !== undefined ? this.libraryId : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        return data;
    }
}

export interface IUserFilter {
    userIds?: number[] | null;
    userTypeIds?: number[] | null;
    name?: string | null;
    email?: string | null;
    libraryId?: number | null;
    pageNumber?: number | null;
    pageSize?: number | null;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

/* tslint:disable */

// ReSharper disable InconsistentNaming

export interface PagedResult<T> {
  items: T[];
  totalCount: number;
  pageSize: number;
  currentPage: number;
}

export function isPagedResult<T>(result: any): result is PagedResult<T> {
  return result && Array.isArray(result.items) && typeof result.totalCount === 'number'
}