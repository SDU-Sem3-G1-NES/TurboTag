//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ApiConfiguration {
  public baseUrl: string
  public instance: AxiosInstance

  constructor(baseUrl: string = 'http://localhost:5088', instance?: AxiosInstance) {
    this.baseUrl = baseUrl
    this.instance =
      instance ||
      axios.create({
        baseURL: baseUrl,
        headers: {
          'Content-Type': 'application/json'
        }
      })

    // Request interceptor for authentication
    this.instance.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('authToken')
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        return config
      },
      (error) => Promise.reject(error)
    )

    // Response interceptor for handling auth errors and token refresh
    this.instance.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config

        // Handle unauthorized errors (401) for token refresh
        if (error.response?.status === 401 && !originalRequest._retry && window.location.pathname !== '/login') {
          originalRequest._retry = true

          try {
            // Attempt to refresh the token
            const refreshToken = localStorage.getItem('refreshToken') || sessionStorage.getItem('refreshToken')
            const accessToken = localStorage.getItem('authToken')
            if (!refreshToken) {
              // No refresh token available, redirect to login
              this.redirectToLogin()
              return Promise.reject(error)
            }

            // Call your token refresh endpoint
            const response = await axios.post(`${baseUrl}/Login/refresh-token`, {
              accessToken, refreshToken
            })

            // If successful, update stored tokens
            if (localStorage.getItem('refreshToken')) {
              localStorage.setItem('refreshToken', response.data.refreshToken)
            } else {
              sessionStorage.setItem('refreshToken', response.data.refreshToken)
            }
            localStorage.setItem('authToken', response.data.accessToken)

            // Update the authorization header and retry
            originalRequest.headers.Authorization = `Bearer ${response.data.accessToken}`
            return axios(originalRequest)
          } catch (refreshError) {
            // If refresh fails, redirect to login
            this.redirectToLogin()
            return Promise.reject(refreshError)
          }
        }

        // Handle forbidden errors (403)
        if (error.response?.status === 403) {
          // Handle access denied - could redirect to forbidden page or show message
          window.location.href = '/forbidden'
          console.error('Access forbidden')
        }

        return Promise.reject(error)
      }
    )
  }

  private redirectToLogin(): void {
    // Clear authentication data
    localStorage.removeItem('authToken')
    localStorage.removeItem('refreshToken')
    localStorage.removeItem('userId')
    localStorage.removeItem('userName')
    sessionStorage.removeItem('refreshToken')
    localStorage.removeItem('userType')

    // Redirect to login page - adjust based on your routing setup
    window.location.href = '/login'
  }
}

export class BaseApiClient {
  protected instance: AxiosInstance
  protected baseUrl: string

  constructor(configuration: ApiConfiguration) {
    this.baseUrl = configuration.baseUrl
    this.instance = configuration.instance
  }
}

export interface IContentLibraryClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            getAllLibraries(body?: LibraryFilter | undefined): Promise<PagedResult<LibraryDto> | LibraryDto[]>                    /**
             * @param libraryId (optional) 
             * @return OK
             */
            getLibraryById(libraryId?: number | undefined): Promise<LibraryDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            createNewLibrary(body?: LibraryDto | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateLibraryById(body?: LibraryDto | undefined): Promise<void>                    /**
             * @param libraryId (optional) 
             * @return OK
             */
            deleteLibraryById(libraryId?: number | undefined): Promise<void>        }

    export class ContentLibraryClient extends BaseApiClient implements IContentLibraryClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getAllLibraries(body?: LibraryFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<LibraryDto> | LibraryDto[]> {        let url_ = this.baseUrl + "/ContentLibrary/GetAllLibraries";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllLibraries(_response);
                });
        }

    protected processGetAllLibraries(response: AxiosResponse): Promise<PagedResult<LibraryDto> | LibraryDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(LibraryDto.fromJS(item));
        } else if (isPagedResult<LibraryDto>(resultData200)) {
            result200 = resultData200 as PagedResult<LibraryDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<LibraryDto> | LibraryDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<LibraryDto> | LibraryDto[]>(null as any);
}
    

        /**
         * @param libraryId (optional) 
         * @return OK
         */
        getLibraryById(libraryId?: number | undefined, cancelToken?: CancelToken): Promise<LibraryDto> {        let url_ = this.baseUrl + "/ContentLibrary/GetLibraryById?";
if (libraryId === null)
    throw new Error("The parameter 'libraryId' cannot be null.");
else if (libraryId !== undefined)
    url_ += "libraryId=" + encodeURIComponent("" + libraryId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLibraryById(_response);
                });
        }

    protected processGetLibraryById(response: AxiosResponse): Promise<LibraryDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = LibraryDto.fromJS(resultData200);
        
        return Promise.resolve<LibraryDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<LibraryDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        createNewLibrary(body?: LibraryDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/ContentLibrary/CreateNewLibrary";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCreateNewLibrary(_response);
                });
        }

    protected processCreateNewLibrary(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateLibraryById(body?: LibraryDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/ContentLibrary/UpdateLibraryById";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateLibraryById(_response);
                });
        }

    protected processUpdateLibraryById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param libraryId (optional) 
         * @return OK
         */
        deleteLibraryById(libraryId?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/ContentLibrary/DeleteLibraryById?";
if (libraryId === null)
    throw new Error("The parameter 'libraryId' cannot be null.");
else if (libraryId !== undefined)
    url_ += "libraryId=" + encodeURIComponent("" + libraryId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteLibraryById(_response);
                });
        }

    protected processDeleteLibraryById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface IFileClient {
                    /**
             * @param file (optional) 
             * @return OK
             */
            uploadFile(file?: FileParameter | undefined): Promise<string>                    /**
             * @param id (optional) 
             * @return OK
             */
            getFileById(id?: string | undefined): Promise<FileResponse>                    /**
             * @param id (optional) 
             * @return OK
             */
            deleteFile(id?: string | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            uploadChunk(body?: UploadChunkDto | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            finalizeUpload(body?: FinaliseUploadDto | undefined): Promise<void>        }

    export class FileClient extends BaseApiClient implements IFileClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param file (optional) 
         * @return OK
         */
        uploadFile(file?: FileParameter | undefined, cancelToken?: CancelToken): Promise<string> {        let url_ = this.baseUrl + "/File/UploadFile";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = new FormData();
            if (file === null || file === undefined)
                throw new Error("The parameter 'file' cannot be null.");
            else
                content_.append("file", file.data, file.fileName ? file.fileName : "file");

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUploadFile(_response);
                });
        }

    protected processUploadFile(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = resultData200 as string;
        
        return Promise.resolve<string>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}
    

        /**
         * @param id (optional) 
         * @return OK
         */
        getFileById(id?: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {        let url_ = this.baseUrl + "/File/GetFileById?";
if (id === null)
    throw new Error("The parameter 'id' cannot be null.");
else if (id !== undefined)
    url_ += "id=" + encodeURIComponent("" + id) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                            responseType: "blob",
                method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetFileById(_response);
                });
        }

    protected processGetFileById(response: AxiosResponse): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = FileResponse.fromJS(resultData200);
        
        return Promise.resolve<FileResponse>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<FileResponse>(null as any);
}
    

        /**
         * @param id (optional) 
         * @return OK
         */
        deleteFile(id?: string | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/File/DeleteFile?";
if (id === null)
    throw new Error("The parameter 'id' cannot be null.");
else if (id !== undefined)
    url_ += "id=" + encodeURIComponent("" + id) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteFile(_response);
                });
        }

    protected processDeleteFile(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        uploadChunk(body?: UploadChunkDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/File/UploadChunk";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUploadChunk(_response);
                });
        }

    protected processUploadChunk(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        finalizeUpload(body?: FinaliseUploadDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/File/FinalizeUpload";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processFinalizeUpload(_response);
                });
        }

    protected processFinalizeUpload(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface ILessonClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            getAllLessons(body?: LessonFilter | undefined): Promise<PagedResult<LessonDto> | LessonDto[]>                    /**
             * @param userId (optional) 
             * @param body (optional) 
             * @return OK
             */
            starLesson(userId?: number | undefined, body?: number | undefined): Promise<void>                    /**
             * @param userId (optional) 
             * @param body (optional) 
             * @return OK
             */
            unstarLesson(userId?: number | undefined, body?: number | undefined): Promise<void>                    /**
             * @param tags (optional) 
             * @return OK
             */
            getLessonsByTags(tags?: string[] | undefined): Promise<PagedResult<LessonDto> | LessonDto[]>                    /**
             * @param title (optional) 
             * @return OK
             */
            getLessonsByTitle(title?: string | undefined): Promise<PagedResult<LessonDto> | LessonDto[]>                    /**
             * @param lessonId (optional) 
             * @return OK
             */
            getLessonById(lessonId?: number | undefined): Promise<LessonDto>                    /**
             * @param objectId (optional) 
             * @return OK
             */
            getLessonByObjectId(objectId?: string | undefined): Promise<LessonDto>                    /**
             * @param uploadId (optional) 
             * @return OK
             */
            getLessonByUploadId(uploadId?: number | undefined): Promise<LessonDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            addLesson(body?: LessonDto | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateLesson(body?: LessonDto | undefined): Promise<void>                    /**
             * @param lessonId (optional) 
             * @return OK
             */
            deleteLessonById(lessonId?: number | undefined): Promise<void>                    /**
             * @param objectId (optional) 
             * @return OK
             */
            deleteLessonByObjectId(objectId?: string | undefined): Promise<void>        }

    export class LessonClient extends BaseApiClient implements ILessonClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getAllLessons(body?: LessonFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<LessonDto> | LessonDto[]> {        let url_ = this.baseUrl + "/Lesson/GetAllLessons";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllLessons(_response);
                });
        }

    protected processGetAllLessons(response: AxiosResponse): Promise<PagedResult<LessonDto> | LessonDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(LessonDto.fromJS(item));
        } else if (isPagedResult<LessonDto>(resultData200)) {
            result200 = resultData200 as PagedResult<LessonDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<LessonDto> | LessonDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<LessonDto> | LessonDto[]>(null as any);
}
    

        /**
         * @param userId (optional) 
         * @param body (optional) 
         * @return OK
         */
        starLesson(userId?: number | undefined, body?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Lesson/StarLesson?";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processStarLesson(_response);
                });
        }

    protected processStarLesson(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param userId (optional) 
         * @param body (optional) 
         * @return OK
         */
        unstarLesson(userId?: number | undefined, body?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Lesson/UnstarLesson?";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUnstarLesson(_response);
                });
        }

    protected processUnstarLesson(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param tags (optional) 
         * @return OK
         */
        getLessonsByTags(tags?: string[] | undefined, cancelToken?: CancelToken): Promise<PagedResult<LessonDto> | LessonDto[]> {        let url_ = this.baseUrl + "/Lesson/GetLessonsByTags?";
if (tags === null)
    throw new Error("The parameter 'tags' cannot be null.");
else if (tags !== undefined)
    tags && tags.forEach(item => { url_ += "tags=" + encodeURIComponent("" + item) + "&"; });
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLessonsByTags(_response);
                });
        }

    protected processGetLessonsByTags(response: AxiosResponse): Promise<PagedResult<LessonDto> | LessonDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(LessonDto.fromJS(item));
        } else if (isPagedResult<LessonDto>(resultData200)) {
            result200 = resultData200 as PagedResult<LessonDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<LessonDto> | LessonDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<LessonDto> | LessonDto[]>(null as any);
}
    

        /**
         * @param title (optional) 
         * @return OK
         */
        getLessonsByTitle(title?: string | undefined, cancelToken?: CancelToken): Promise<PagedResult<LessonDto> | LessonDto[]> {        let url_ = this.baseUrl + "/Lesson/GetLessonsByTitle?";
if (title === null)
    throw new Error("The parameter 'title' cannot be null.");
else if (title !== undefined)
    url_ += "title=" + encodeURIComponent("" + title) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLessonsByTitle(_response);
                });
        }

    protected processGetLessonsByTitle(response: AxiosResponse): Promise<PagedResult<LessonDto> | LessonDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(LessonDto.fromJS(item));
        } else if (isPagedResult<LessonDto>(resultData200)) {
            result200 = resultData200 as PagedResult<LessonDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<LessonDto> | LessonDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<LessonDto> | LessonDto[]>(null as any);
}
    

        /**
         * @param lessonId (optional) 
         * @return OK
         */
        getLessonById(lessonId?: number | undefined, cancelToken?: CancelToken): Promise<LessonDto> {        let url_ = this.baseUrl + "/Lesson/GetLessonById?";
if (lessonId === null)
    throw new Error("The parameter 'lessonId' cannot be null.");
else if (lessonId !== undefined)
    url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLessonById(_response);
                });
        }

    protected processGetLessonById(response: AxiosResponse): Promise<LessonDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = LessonDto.fromJS(resultData200);
        
        return Promise.resolve<LessonDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<LessonDto>(null as any);
}
    

        /**
         * @param objectId (optional) 
         * @return OK
         */
        getLessonByObjectId(objectId?: string | undefined, cancelToken?: CancelToken): Promise<LessonDto> {        let url_ = this.baseUrl + "/Lesson/GetLessonByObjectId?";
if (objectId === null)
    throw new Error("The parameter 'objectId' cannot be null.");
else if (objectId !== undefined)
    url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLessonByObjectId(_response);
                });
        }

    protected processGetLessonByObjectId(response: AxiosResponse): Promise<LessonDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = LessonDto.fromJS(resultData200);
        
        return Promise.resolve<LessonDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<LessonDto>(null as any);
}
    

        /**
         * @param uploadId (optional) 
         * @return OK
         */
        getLessonByUploadId(uploadId?: number | undefined, cancelToken?: CancelToken): Promise<LessonDto> {        let url_ = this.baseUrl + "/Lesson/GetLessonByUploadId?";
if (uploadId === null)
    throw new Error("The parameter 'uploadId' cannot be null.");
else if (uploadId !== undefined)
    url_ += "uploadId=" + encodeURIComponent("" + uploadId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLessonByUploadId(_response);
                });
        }

    protected processGetLessonByUploadId(response: AxiosResponse): Promise<LessonDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = LessonDto.fromJS(resultData200);
        
        return Promise.resolve<LessonDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<LessonDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        addLesson(body?: LessonDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Lesson/AddLesson";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processAddLesson(_response);
                });
        }

    protected processAddLesson(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateLesson(body?: LessonDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Lesson/UpdateLesson";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateLesson(_response);
                });
        }

    protected processUpdateLesson(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param lessonId (optional) 
         * @return OK
         */
        deleteLessonById(lessonId?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Lesson/DeleteLessonById?";
if (lessonId === null)
    throw new Error("The parameter 'lessonId' cannot be null.");
else if (lessonId !== undefined)
    url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteLessonById(_response);
                });
        }

    protected processDeleteLessonById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param objectId (optional) 
         * @return OK
         */
        deleteLessonByObjectId(objectId?: string | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Lesson/DeleteLessonByObjectId?";
if (objectId === null)
    throw new Error("The parameter 'objectId' cannot be null.");
else if (objectId !== undefined)
    url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteLessonByObjectId(_response);
                });
        }

    protected processDeleteLessonByObjectId(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface ILoginClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUserCredentials(body?: UserIdPassword | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            login(body?: UserCredentialsDto | undefined): Promise<SignInResponse>                    /**
             * @param body (optional) 
             * @return OK
             */
            refreshToken(body?: TokenModel | undefined): Promise<void>                    /**
             * @return OK
             */
            logout(): Promise<void>        }

    export class LoginClient extends BaseApiClient implements ILoginClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUserCredentials(body?: UserIdPassword | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Login/UpdateUserCredentials";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUserCredentials(_response);
                });
        }

    protected processUpdateUserCredentials(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        login(body?: UserCredentialsDto | undefined, cancelToken?: CancelToken): Promise<SignInResponse> {        let url_ = this.baseUrl + "/Login/login";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processLogin(_response);
                });
        }

    protected processLogin(response: AxiosResponse): Promise<SignInResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = SignInResponse.fromJS(resultData200);
        
        return Promise.resolve<SignInResponse>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<SignInResponse>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        refreshToken(body?: TokenModel | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Login/refresh-token";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processRefreshToken(_response);
                });
        }

    protected processRefreshToken(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @return OK
         */
        logout( cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Login/logout";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "POST",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processLogout(_response);
                });
        }

    protected processLogout(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface IOptionsClient {
                    /**
             * @param pageNumber (optional) 
             * @param pageSize (optional) 
             * @param userId (optional) 
             * @param searchText (optional) 
             * @return OK
             */
            getTagOptions(pageNumber?: number | undefined, pageSize?: number | undefined, userId?: number | undefined, searchText?: string | undefined): Promise<PagedResult<OptionDto> | OptionDto[]>                    /**
             * @param pageNumber (optional) 
             * @param pageSize (optional) 
             * @param userId (optional) 
             * @param searchText (optional) 
             * @return OK
             */
            getUploaderOptions(pageNumber?: number | undefined, pageSize?: number | undefined, userId?: number | undefined, searchText?: string | undefined): Promise<PagedResult<OptionDto> | OptionDto[]>        }

    export class OptionsClient extends BaseApiClient implements IOptionsClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param pageNumber (optional) 
         * @param pageSize (optional) 
         * @param userId (optional) 
         * @param searchText (optional) 
         * @return OK
         */
        getTagOptions(pageNumber?: number | undefined, pageSize?: number | undefined, userId?: number | undefined, searchText?: string | undefined, cancelToken?: CancelToken): Promise<PagedResult<OptionDto> | OptionDto[]> {        let url_ = this.baseUrl + "/Options/GetTagOptions?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
if (searchText === null)
    throw new Error("The parameter 'searchText' cannot be null.");
else if (searchText !== undefined)
    url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetTagOptions(_response);
                });
        }

    protected processGetTagOptions(response: AxiosResponse): Promise<PagedResult<OptionDto> | OptionDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(OptionDto.fromJS(item));
        } else if (isPagedResult<OptionDto>(resultData200)) {
            result200 = resultData200 as PagedResult<OptionDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<OptionDto> | OptionDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<OptionDto> | OptionDto[]>(null as any);
}
    

        /**
         * @param pageNumber (optional) 
         * @param pageSize (optional) 
         * @param userId (optional) 
         * @param searchText (optional) 
         * @return OK
         */
        getUploaderOptions(pageNumber?: number | undefined, pageSize?: number | undefined, userId?: number | undefined, searchText?: string | undefined, cancelToken?: CancelToken): Promise<PagedResult<OptionDto> | OptionDto[]> {        let url_ = this.baseUrl + "/Options/GetUploaderOptions?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
if (searchText === null)
    throw new Error("The parameter 'searchText' cannot be null.");
else if (searchText !== undefined)
    url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUploaderOptions(_response);
                });
        }

    protected processGetUploaderOptions(response: AxiosResponse): Promise<PagedResult<OptionDto> | OptionDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(OptionDto.fromJS(item));
        } else if (isPagedResult<OptionDto>(resultData200)) {
            result200 = resultData200 as PagedResult<OptionDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<OptionDto> | OptionDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<OptionDto> | OptionDto[]>(null as any);
}
        }

            export interface ISettingsClient {
                    /**
             * @return OK
             */
            getAllSettings(): Promise<PagedResult<SettingsDto> | SettingsDto[]>                    /**
             * @param settingId (optional) 
             * @return OK
             */
            getSettingById(settingId?: number | undefined): Promise<SettingsDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            addSetting(body?: SettingsDto | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateSetting(body?: SettingsDto | undefined): Promise<void>                    /**
             * @param settingId (optional) 
             * @return OK
             */
            deleteSettingById(settingId?: number | undefined): Promise<void>        }

    export class SettingsClient extends BaseApiClient implements ISettingsClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @return OK
         */
        getAllSettings( cancelToken?: CancelToken): Promise<PagedResult<SettingsDto> | SettingsDto[]> {        let url_ = this.baseUrl + "/Settings/GetAllSettings";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllSettings(_response);
                });
        }

    protected processGetAllSettings(response: AxiosResponse): Promise<PagedResult<SettingsDto> | SettingsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(SettingsDto.fromJS(item));
        } else if (isPagedResult<SettingsDto>(resultData200)) {
            result200 = resultData200 as PagedResult<SettingsDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<SettingsDto> | SettingsDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<SettingsDto> | SettingsDto[]>(null as any);
}
    

        /**
         * @param settingId (optional) 
         * @return OK
         */
        getSettingById(settingId?: number | undefined, cancelToken?: CancelToken): Promise<SettingsDto> {        let url_ = this.baseUrl + "/Settings/GetSettingById?";
if (settingId === null)
    throw new Error("The parameter 'settingId' cannot be null.");
else if (settingId !== undefined)
    url_ += "settingId=" + encodeURIComponent("" + settingId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetSettingById(_response);
                });
        }

    protected processGetSettingById(response: AxiosResponse): Promise<SettingsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = SettingsDto.fromJS(resultData200);
        
        return Promise.resolve<SettingsDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<SettingsDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        addSetting(body?: SettingsDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Settings/AddSetting";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processAddSetting(_response);
                });
        }

    protected processAddSetting(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateSetting(body?: SettingsDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Settings/UpdateSetting";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateSetting(_response);
                });
        }

    protected processUpdateSetting(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param settingId (optional) 
         * @return OK
         */
        deleteSettingById(settingId?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Settings/DeleteSettingById?";
if (settingId === null)
    throw new Error("The parameter 'settingId' cannot be null.");
else if (settingId !== undefined)
    url_ += "settingId=" + encodeURIComponent("" + settingId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteSettingById(_response);
                });
        }

    protected processDeleteSettingById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface IUploadClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            getAllUploads(body?: UploadFilter | undefined): Promise<PagedResult<UploadDto> | UploadDto[]>                    /**
             * @param body (optional) 
             * @return OK
             */
            getUserUploads(body?: UserDtoUploadFilterValueTuple | undefined): Promise<PagedResult<UploadDto> | UploadDto[]>                    /**
             * @param libraryId (optional) 
             * @param body (optional) 
             * @return OK
             */
            getLibraryUploads(libraryId?: number | undefined, body?: UploadFilter | undefined): Promise<PagedResult<UploadDto> | UploadDto[]>                    /**
             * @param uploadId (optional) 
             * @return OK
             */
            getUploadById(uploadId?: number | undefined): Promise<UploadDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            addUpload(body?: UploadDto | undefined): Promise<number>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUpload(body?: UploadDto | undefined): Promise<void>                    /**
             * @param uploadId (optional) 
             * @return OK
             */
            deleteUploadById(uploadId?: number | undefined): Promise<void>        }

    export class UploadClient extends BaseApiClient implements IUploadClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getAllUploads(body?: UploadFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<UploadDto> | UploadDto[]> {        let url_ = this.baseUrl + "/Upload/GetAllUploads";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllUploads(_response);
                });
        }

    protected processGetAllUploads(response: AxiosResponse): Promise<PagedResult<UploadDto> | UploadDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UploadDto.fromJS(item));
        } else if (isPagedResult<UploadDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UploadDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getUserUploads(body?: UserDtoUploadFilterValueTuple | undefined, cancelToken?: CancelToken): Promise<PagedResult<UploadDto> | UploadDto[]> {        let url_ = this.baseUrl + "/Upload/GetUserUploads";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserUploads(_response);
                });
        }

    protected processGetUserUploads(response: AxiosResponse): Promise<PagedResult<UploadDto> | UploadDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UploadDto.fromJS(item));
        } else if (isPagedResult<UploadDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UploadDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(null as any);
}
    

        /**
         * @param libraryId (optional) 
         * @param body (optional) 
         * @return OK
         */
        getLibraryUploads(libraryId?: number | undefined, body?: UploadFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<UploadDto> | UploadDto[]> {        let url_ = this.baseUrl + "/Upload/GetLibraryUploads?";
if (libraryId === null)
    throw new Error("The parameter 'libraryId' cannot be null.");
else if (libraryId !== undefined)
    url_ += "libraryId=" + encodeURIComponent("" + libraryId) + "&";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLibraryUploads(_response);
                });
        }

    protected processGetLibraryUploads(response: AxiosResponse): Promise<PagedResult<UploadDto> | UploadDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UploadDto.fromJS(item));
        } else if (isPagedResult<UploadDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UploadDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(null as any);
}
    

        /**
         * @param uploadId (optional) 
         * @return OK
         */
        getUploadById(uploadId?: number | undefined, cancelToken?: CancelToken): Promise<UploadDto> {        let url_ = this.baseUrl + "/Upload/GetUploadById?";
if (uploadId === null)
    throw new Error("The parameter 'uploadId' cannot be null.");
else if (uploadId !== undefined)
    url_ += "uploadId=" + encodeURIComponent("" + uploadId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUploadById(_response);
                });
        }

    protected processGetUploadById(response: AxiosResponse): Promise<UploadDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = UploadDto.fromJS(resultData200);
        
        return Promise.resolve<UploadDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<UploadDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        addUpload(body?: UploadDto | undefined, cancelToken?: CancelToken): Promise<number> {        let url_ = this.baseUrl + "/Upload/AddUpload";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processAddUpload(_response);
                });
        }

    protected processAddUpload(response: AxiosResponse): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = resultData200 as number;
        
        return Promise.resolve<number>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<number>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUpload(body?: UploadDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Upload/UpdateUpload";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUpload(_response);
                });
        }

    protected processUpdateUpload(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param uploadId (optional) 
         * @return OK
         */
        deleteUploadById(uploadId?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Upload/DeleteUploadById?";
if (uploadId === null)
    throw new Error("The parameter 'uploadId' cannot be null.");
else if (uploadId !== undefined)
    url_ += "uploadId=" + encodeURIComponent("" + uploadId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteUploadById(_response);
                });
        }

    protected processDeleteUploadById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface IUserClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            getAllUsers(body?: UserFilter | undefined): Promise<PagedResult<UserDto> | UserDto[]>                    /**
             * @param body (optional) 
             * @return OK
             */
            getUserNames(body?: UserFilter | undefined): Promise<PagedResult<UserName> | UserName[]>                    /**
             * @param email (optional) 
             * @return OK
             */
            getUserByEmail(email?: string | undefined): Promise<UserDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            createNewUser(body?: UserRequest | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUserById(body?: UserRequest | undefined): Promise<void>                    /**
             * @param userId (optional) 
             * @return OK
             */
            deleteUserById(userId?: number | undefined): Promise<void>                    /**
             * @param email (optional) 
             * @return OK
             */
            userExists(email?: string | undefined): Promise<boolean>        }

    export class UserClient extends BaseApiClient implements IUserClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getAllUsers(body?: UserFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<UserDto> | UserDto[]> {        let url_ = this.baseUrl + "/User/GetAllUsers";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllUsers(_response);
                });
        }

    protected processGetAllUsers(response: AxiosResponse): Promise<PagedResult<UserDto> | UserDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UserDto.fromJS(item));
        } else if (isPagedResult<UserDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UserDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UserDto> | UserDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UserDto> | UserDto[]>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getUserNames(body?: UserFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<UserName> | UserName[]> {        let url_ = this.baseUrl + "/User/GetUserNames";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserNames(_response);
                });
        }

    protected processGetUserNames(response: AxiosResponse): Promise<PagedResult<UserName> | UserName[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UserName.fromJS(item));
        } else if (isPagedResult<UserName>(resultData200)) {
            result200 = resultData200 as PagedResult<UserName>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UserName> | UserName[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UserName> | UserName[]>(null as any);
}
    

        /**
         * @param email (optional) 
         * @return OK
         */
        getUserByEmail(email?: string | undefined, cancelToken?: CancelToken): Promise<UserDto> {        let url_ = this.baseUrl + "/User/GetUserByEmail?";
if (email === null)
    throw new Error("The parameter 'email' cannot be null.");
else if (email !== undefined)
    url_ += "email=" + encodeURIComponent("" + email) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserByEmail(_response);
                });
        }

    protected processGetUserByEmail(response: AxiosResponse): Promise<UserDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = UserDto.fromJS(resultData200);
        
        return Promise.resolve<UserDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<UserDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        createNewUser(body?: UserRequest | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/User/CreateNewUser";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCreateNewUser(_response);
                });
        }

    protected processCreateNewUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUserById(body?: UserRequest | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/User/UpdateUserById";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUserById(_response);
                });
        }

    protected processUpdateUserById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param userId (optional) 
         * @return OK
         */
        deleteUserById(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/User/DeleteUserById?";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteUserById(_response);
                });
        }

    protected processDeleteUserById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param email (optional) 
         * @return OK
         */
        userExists(email?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {        let url_ = this.baseUrl + "/User/UserExists?";
if (email === null)
    throw new Error("The parameter 'email' cannot be null.");
else if (email !== undefined)
    url_ += "email=" + encodeURIComponent("" + email) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUserExists(_response);
                });
        }

    protected processUserExists(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = resultData200 as boolean;
        
        return Promise.resolve<boolean>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}
        }

            export interface IUserTypeClient {
                    /**
             * @return OK
             */
            getAllUserTypes(): Promise<PagedResult<UserTypeDto> | UserTypeDto[]>                    /**
             * @param id (optional) 
             * @return OK
             */
            getUserTypeById(id?: number | undefined): Promise<UserTypeDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            addUserType(body?: UserTypeDto | undefined): Promise<void>        }

    export class UserTypeClient extends BaseApiClient implements IUserTypeClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @return OK
         */
        getAllUserTypes( cancelToken?: CancelToken): Promise<PagedResult<UserTypeDto> | UserTypeDto[]> {        let url_ = this.baseUrl + "/UserType/GetAllUserTypes";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllUserTypes(_response);
                });
        }

    protected processGetAllUserTypes(response: AxiosResponse): Promise<PagedResult<UserTypeDto> | UserTypeDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UserTypeDto.fromJS(item));
        } else if (isPagedResult<UserTypeDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UserTypeDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UserTypeDto> | UserTypeDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UserTypeDto> | UserTypeDto[]>(null as any);
}
    

        /**
         * @param id (optional) 
         * @return OK
         */
        getUserTypeById(id?: number | undefined, cancelToken?: CancelToken): Promise<UserTypeDto> {        let url_ = this.baseUrl + "/UserType/GetUserTypeById?";
if (id === null)
    throw new Error("The parameter 'id' cannot be null.");
else if (id !== undefined)
    url_ += "id=" + encodeURIComponent("" + id) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserTypeById(_response);
                });
        }

    protected processGetUserTypeById(response: AxiosResponse): Promise<UserTypeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = UserTypeDto.fromJS(resultData200);
        
        return Promise.resolve<UserTypeDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<UserTypeDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        addUserType(body?: UserTypeDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/UserType/AddUserType";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processAddUserType(_response);
                });
        }

    protected processAddUserType(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

export class FileMetadataDto implements IFileMetadataDto {
    id?: string | null;
    fileType?: string | null;
    fileName?: string | null;
    fileSize?: number | null;
    duration?: number | null;
    date?: Date | null;
    checkSum?: string | null;

    constructor(data?: IFileMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.fileType = _data["fileType"] !== undefined ? _data["fileType"] : <any>null;
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
            this.fileSize = _data["fileSize"] !== undefined ? _data["fileSize"] : <any>null;
            this.duration = _data["duration"] !== undefined ? _data["duration"] : <any>null;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.checkSum = _data["checkSum"] !== undefined ? _data["checkSum"] : <any>null;
        }
    }

    static fromJS(data: any): FileMetadataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileMetadataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["fileType"] = this.fileType !== undefined ? this.fileType : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["fileSize"] = this.fileSize !== undefined ? this.fileSize : <any>null;
        data["duration"] = this.duration !== undefined ? this.duration : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["checkSum"] = this.checkSum !== undefined ? this.checkSum : <any>null;
        return data;
    }
}

export interface IFileMetadataDto {
    id?: string | null;
    fileType?: string | null;
    fileName?: string | null;
    fileSize?: number | null;
    duration?: number | null;
    date?: Date | null;
    checkSum?: string | null;
}

export class FinaliseUploadDto implements IFinaliseUploadDto {
    uploadId?: string | null;
    fileName?: string | null;

    constructor(data?: IFinaliseUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uploadId = _data["uploadId"] !== undefined ? _data["uploadId"] : <any>null;
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
        }
    }

    static fromJS(data: any): FinaliseUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new FinaliseUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uploadId"] = this.uploadId !== undefined ? this.uploadId : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        return data;
    }
}

export interface IFinaliseUploadDto {
    uploadId?: string | null;
    fileName?: string | null;
}

export class LessonDetailsDto implements ILessonDetailsDto {
    id?: number | null;
    title?: string | null;
    description?: string | null;
    tags?: string[] | null;

    constructor(data?: ILessonDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
        }
    }

    static fromJS(data: any): LessonDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ILessonDetailsDto {
    id?: number | null;
    title?: string | null;
    description?: string | null;
    tags?: string[] | null;
}

export class LessonDto implements ILessonDto {
    mongoId?: string | null;
    uploadId?: number | null;
    lessonDetails?: LessonDetailsDto;
    fileMetadata?: FileMetadataDto[] | null;
    ownerId?: number | null;
    ownerName?: string | null;
    isStarred?: boolean;

    constructor(data?: ILessonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mongoId = _data["mongoId"] !== undefined ? _data["mongoId"] : <any>null;
            this.uploadId = _data["uploadId"] !== undefined ? _data["uploadId"] : <any>null;
            this.lessonDetails = _data["lessonDetails"] ? LessonDetailsDto.fromJS(_data["lessonDetails"]) : <any>null;
            if (Array.isArray(_data["fileMetadata"])) {
                this.fileMetadata = [] as any;
                for (let item of _data["fileMetadata"])
                    this.fileMetadata!.push(FileMetadataDto.fromJS(item));
            }
            else {
                this.fileMetadata = <any>null;
            }
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            this.ownerName = _data["ownerName"] !== undefined ? _data["ownerName"] : <any>null;
            this.isStarred = _data["isStarred"] !== undefined ? _data["isStarred"] : <any>null;
        }
    }

    static fromJS(data: any): LessonDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mongoId"] = this.mongoId !== undefined ? this.mongoId : <any>null;
        data["uploadId"] = this.uploadId !== undefined ? this.uploadId : <any>null;
        data["lessonDetails"] = this.lessonDetails ? this.lessonDetails.toJSON() : <any>null;
        if (Array.isArray(this.fileMetadata)) {
            data["fileMetadata"] = [];
            for (let item of this.fileMetadata)
                data["fileMetadata"].push(item ? item.toJSON() : <any>null);
        }
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        data["ownerName"] = this.ownerName !== undefined ? this.ownerName : <any>null;
        data["isStarred"] = this.isStarred !== undefined ? this.isStarred : <any>null;
        return data;
    }
}

export interface ILessonDto {
    mongoId?: string | null;
    uploadId?: number | null;
    lessonDetails?: LessonDetailsDto;
    fileMetadata?: FileMetadataDto[] | null;
    ownerId?: number | null;
    ownerName?: string | null;
    isStarred?: boolean;
}

export class LessonFilter implements ILessonFilter {
    title?: string | null;
    tags?: string[] | null;
    ownerId?: number | null;
    ownerIdInts?: number[] | null;
    userId?: number | null;
    uploadIds?: number[] | null;
    lessonId?: number | null;
    pageSize?: number | null;
    pageNumber?: number | null;
    searchText?: string | null;
    isStarred?: boolean | null;
    starredLessons?: number[] | null;

    constructor(data?: ILessonFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            if (Array.isArray(_data["ownerIdInts"])) {
                this.ownerIdInts = [] as any;
                for (let item of _data["ownerIdInts"])
                    this.ownerIdInts!.push(item);
            }
            else {
                this.ownerIdInts = <any>null;
            }
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            if (Array.isArray(_data["uploadIds"])) {
                this.uploadIds = [] as any;
                for (let item of _data["uploadIds"])
                    this.uploadIds!.push(item);
            }
            else {
                this.uploadIds = <any>null;
            }
            this.lessonId = _data["lessonId"] !== undefined ? _data["lessonId"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.searchText = _data["searchText"] !== undefined ? _data["searchText"] : <any>null;
            this.isStarred = _data["isStarred"] !== undefined ? _data["isStarred"] : <any>null;
            if (Array.isArray(_data["starredLessons"])) {
                this.starredLessons = [] as any;
                for (let item of _data["starredLessons"])
                    this.starredLessons!.push(item);
            }
            else {
                this.starredLessons = <any>null;
            }
        }
    }

    static fromJS(data: any): LessonFilter {
        data = typeof data === 'object' ? data : {};
        let result = new LessonFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        if (Array.isArray(this.ownerIdInts)) {
            data["ownerIdInts"] = [];
            for (let item of this.ownerIdInts)
                data["ownerIdInts"].push(item);
        }
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        if (Array.isArray(this.uploadIds)) {
            data["uploadIds"] = [];
            for (let item of this.uploadIds)
                data["uploadIds"].push(item);
        }
        data["lessonId"] = this.lessonId !== undefined ? this.lessonId : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["searchText"] = this.searchText !== undefined ? this.searchText : <any>null;
        data["isStarred"] = this.isStarred !== undefined ? this.isStarred : <any>null;
        if (Array.isArray(this.starredLessons)) {
            data["starredLessons"] = [];
            for (let item of this.starredLessons)
                data["starredLessons"].push(item);
        }
        return data;
    }
}

export interface ILessonFilter {
    title?: string | null;
    tags?: string[] | null;
    ownerId?: number | null;
    ownerIdInts?: number[] | null;
    userId?: number | null;
    uploadIds?: number[] | null;
    lessonId?: number | null;
    pageSize?: number | null;
    pageNumber?: number | null;
    searchText?: string | null;
    isStarred?: boolean | null;
    starredLessons?: number[] | null;
}

export class LibraryDto implements ILibraryDto {
    id?: number;
    name?: string | null;

    constructor(data?: ILibraryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): LibraryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LibraryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ILibraryDto {
    id?: number;
    name?: string | null;
}

export class LibraryFilter implements ILibraryFilter {
    libraryIds?: number[] | null;
    libraryName?: string | null;
    pageSize?: number | null;
    pageNumber?: number | null;

    constructor(data?: ILibraryFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["libraryIds"])) {
                this.libraryIds = [] as any;
                for (let item of _data["libraryIds"])
                    this.libraryIds!.push(item);
            }
            else {
                this.libraryIds = <any>null;
            }
            this.libraryName = _data["libraryName"] !== undefined ? _data["libraryName"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
        }
    }

    static fromJS(data: any): LibraryFilter {
        data = typeof data === 'object' ? data : {};
        let result = new LibraryFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.libraryIds)) {
            data["libraryIds"] = [];
            for (let item of this.libraryIds)
                data["libraryIds"].push(item);
        }
        data["libraryName"] = this.libraryName !== undefined ? this.libraryName : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        return data;
    }
}

export interface ILibraryFilter {
    libraryIds?: number[] | null;
    libraryName?: string | null;
    pageSize?: number | null;
    pageNumber?: number | null;
}

export class OptionDto implements IOptionDto {
    displayText?: string | null;
    value?: string | null;

    constructor(data?: IOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayText = _data["displayText"] !== undefined ? _data["displayText"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): OptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayText"] = this.displayText !== undefined ? this.displayText : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IOptionDto {
    displayText?: string | null;
    value?: string | null;
}

export class PagedResult_LessonDto implements IPagedResult_LessonDto {
    items?: LessonDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_LessonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LessonDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_LessonDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_LessonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_LessonDto {
    items?: LessonDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_LibraryDto implements IPagedResult_LibraryDto {
    items?: LibraryDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_LibraryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LibraryDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_LibraryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_LibraryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_LibraryDto {
    items?: LibraryDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_OptionDto implements IPagedResult_OptionDto {
    items?: OptionDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_OptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OptionDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_OptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_OptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_OptionDto {
    items?: OptionDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_SettingsDto implements IPagedResult_SettingsDto {
    items?: SettingsDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_SettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SettingsDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_SettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_SettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_SettingsDto {
    items?: SettingsDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_UploadDto implements IPagedResult_UploadDto {
    items?: UploadDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_UploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UploadDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_UploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_UploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_UploadDto {
    items?: UploadDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_UserDto implements IPagedResult_UserDto {
    items?: UserDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_UserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_UserDto {
    items?: UserDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_UserName implements IPagedResult_UserName {
    items?: UserName[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_UserName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserName.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_UserName {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_UserName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_UserName {
    items?: UserName[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_UserTypeDto implements IPagedResult_UserTypeDto {
    items?: UserTypeDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_UserTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserTypeDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_UserTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_UserTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_UserTypeDto {
    items?: UserTypeDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class SettingsDto implements ISettingsDto {
    id?: number;
    name?: string | null;
    value?: string | null;

    constructor(data?: ISettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): SettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface ISettingsDto {
    id?: number;
    name?: string | null;
    value?: string | null;
}

export class SignInResponse implements ISignInResponse {
    accessToken?: string | null;
    refreshToken?: string | null;
    userId?: number;
    name?: string | null;
    userType?: string | null;

    constructor(data?: ISignInResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] !== undefined ? _data["accessToken"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.userType = _data["userType"] !== undefined ? _data["userType"] : <any>null;
        }
    }

    static fromJS(data: any): SignInResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SignInResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken !== undefined ? this.accessToken : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["userType"] = this.userType !== undefined ? this.userType : <any>null;
        return data;
    }
}

export interface ISignInResponse {
    accessToken?: string | null;
    refreshToken?: string | null;
    userId?: number;
    name?: string | null;
    userType?: string | null;
}

export class TokenModel implements ITokenModel {
    accessToken?: string | null;
    refreshToken?: string | null;

    constructor(data?: ITokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] !== undefined ? _data["accessToken"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
        }
    }

    static fromJS(data: any): TokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken !== undefined ? this.accessToken : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        return data;
    }
}

export interface ITokenModel {
    accessToken?: string | null;
    refreshToken?: string | null;
}

export class UploadChunkDto implements IUploadChunkDto {
    chunk?: string | null;
    uploadId?: string | null;
    chunkNumber?: number;

    constructor(data?: IUploadChunkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chunk = _data["chunk"] !== undefined ? _data["chunk"] : <any>null;
            this.uploadId = _data["uploadId"] !== undefined ? _data["uploadId"] : <any>null;
            this.chunkNumber = _data["chunkNumber"] !== undefined ? _data["chunkNumber"] : <any>null;
        }
    }

    static fromJS(data: any): UploadChunkDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadChunkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chunk"] = this.chunk !== undefined ? this.chunk : <any>null;
        data["uploadId"] = this.uploadId !== undefined ? this.uploadId : <any>null;
        data["chunkNumber"] = this.chunkNumber !== undefined ? this.chunkNumber : <any>null;
        return data;
    }
}

export interface IUploadChunkDto {
    chunk?: string | null;
    uploadId?: string | null;
    chunkNumber?: number;
}

export class UploadDto implements IUploadDto {
    id?: number;
    ownerId?: number;
    date?: Date;
    type?: string | null;
    libraryId?: number;

    constructor(data?: IUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.libraryId = _data["libraryId"] !== undefined ? _data["libraryId"] : <any>null;
        }
    }

    static fromJS(data: any): UploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["libraryId"] = this.libraryId !== undefined ? this.libraryId : <any>null;
        return data;
    }
}

export interface IUploadDto {
    id?: number;
    ownerId?: number;
    date?: Date;
    type?: string | null;
    libraryId?: number;
}

export class UploadFilter implements IUploadFilter {
    uploadIds?: number[] | null;
    ownerIds?: number[] | null;
    libraryIds?: number[] | null;
    uploadTypes?: string[] | null;
    dateFrom?: Date | null;
    dateTo?: Date | null;
    pageNumber?: number | null;
    pageSize?: number | null;

    constructor(data?: IUploadFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["uploadIds"])) {
                this.uploadIds = [] as any;
                for (let item of _data["uploadIds"])
                    this.uploadIds!.push(item);
            }
            else {
                this.uploadIds = <any>null;
            }
            if (Array.isArray(_data["ownerIds"])) {
                this.ownerIds = [] as any;
                for (let item of _data["ownerIds"])
                    this.ownerIds!.push(item);
            }
            else {
                this.ownerIds = <any>null;
            }
            if (Array.isArray(_data["libraryIds"])) {
                this.libraryIds = [] as any;
                for (let item of _data["libraryIds"])
                    this.libraryIds!.push(item);
            }
            else {
                this.libraryIds = <any>null;
            }
            if (Array.isArray(_data["uploadTypes"])) {
                this.uploadTypes = [] as any;
                for (let item of _data["uploadTypes"])
                    this.uploadTypes!.push(item);
            }
            else {
                this.uploadTypes = <any>null;
            }
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>null;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
        }
    }

    static fromJS(data: any): UploadFilter {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.uploadIds)) {
            data["uploadIds"] = [];
            for (let item of this.uploadIds)
                data["uploadIds"].push(item);
        }
        if (Array.isArray(this.ownerIds)) {
            data["ownerIds"] = [];
            for (let item of this.ownerIds)
                data["ownerIds"].push(item);
        }
        if (Array.isArray(this.libraryIds)) {
            data["libraryIds"] = [];
            for (let item of this.libraryIds)
                data["libraryIds"].push(item);
        }
        if (Array.isArray(this.uploadTypes)) {
            data["uploadTypes"] = [];
            for (let item of this.uploadTypes)
                data["uploadTypes"].push(item);
        }
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        return data;
    }
}

export interface IUploadFilter {
    uploadIds?: number[] | null;
    ownerIds?: number[] | null;
    libraryIds?: number[] | null;
    uploadTypes?: string[] | null;
    dateFrom?: Date | null;
    dateTo?: Date | null;
    pageNumber?: number | null;
    pageSize?: number | null;
}

export class UserCredentialsDto implements IUserCredentialsDto {
    email?: string | null;
    password?: string | null;

    constructor(data?: IUserCredentialsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UserCredentialsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserCredentialsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IUserCredentialsDto {
    email?: string | null;
    password?: string | null;
}

export class UserDto implements IUserDto {
    id?: number;
    userTypeId?: number;
    name?: string | null;
    email?: string | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userTypeId = _data["userTypeId"] !== undefined ? _data["userTypeId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userTypeId"] = this.userTypeId !== undefined ? this.userTypeId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data;
    }
}

export interface IUserDto {
    id?: number;
    userTypeId?: number;
    name?: string | null;
    email?: string | null;
}

export class UserDtoUploadFilterValueTuple implements IUserDtoUploadFilterValueTuple {

    constructor(data?: IUserDtoUploadFilterValueTuple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): UserDtoUploadFilterValueTuple {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoUploadFilterValueTuple();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IUserDtoUploadFilterValueTuple {
}

export class UserFilter implements IUserFilter {
    userIds?: number[] | null;
    userTypeIds?: number[] | null;
    name?: string | null;
    email?: string | null;
    pageNumber?: number | null;
    pageSize?: number | null;

    constructor(data?: IUserFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            else {
                this.userIds = <any>null;
            }
            if (Array.isArray(_data["userTypeIds"])) {
                this.userTypeIds = [] as any;
                for (let item of _data["userTypeIds"])
                    this.userTypeIds!.push(item);
            }
            else {
                this.userTypeIds = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
        }
    }

    static fromJS(data: any): UserFilter {
        data = typeof data === 'object' ? data : {};
        let result = new UserFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        if (Array.isArray(this.userTypeIds)) {
            data["userTypeIds"] = [];
            for (let item of this.userTypeIds)
                data["userTypeIds"].push(item);
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        return data;
    }
}

export interface IUserFilter {
    userIds?: number[] | null;
    userTypeIds?: number[] | null;
    name?: string | null;
    email?: string | null;
    pageNumber?: number | null;
    pageSize?: number | null;
}

export class UserIdPassword implements IUserIdPassword {
    userId?: number;
    password?: string | null;

    constructor(data?: IUserIdPassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UserIdPassword {
        data = typeof data === 'object' ? data : {};
        let result = new UserIdPassword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IUserIdPassword {
    userId?: number;
    password?: string | null;
}

export class UserName implements IUserName {
    id?: number;
    name?: string | null;

    constructor(data?: IUserName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): UserName {
        data = typeof data === 'object' ? data : {};
        let result = new UserName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface IUserName {
    id?: number;
    name?: string | null;
}

export class UserRequest implements IUserRequest {
    user?: UserDto;
    password?: string | null;

    constructor(data?: IUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IUserRequest {
    user?: UserDto;
    password?: string | null;
}

export class UserTypeDto implements IUserTypeDto {
    id?: number;
    name?: string | null;
    permissions?: { [key: string]: boolean; } | null;

    constructor(data?: IUserTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (_data["permissions"]) {
                this.permissions = {} as any;
                for (let key in _data["permissions"]) {
                    if (_data["permissions"].hasOwnProperty(key))
                        (<any>this.permissions)![key] = _data["permissions"][key] !== undefined ? _data["permissions"][key] : <any>null;
                }
            }
            else {
                this.permissions = <any>null;
            }
        }
    }

    static fromJS(data: any): UserTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.permissions) {
            data["permissions"] = {};
            for (let key in this.permissions) {
                if (this.permissions.hasOwnProperty(key))
                    (<any>data["permissions"])[key] = this.permissions[key] !== undefined ? this.permissions[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IUserTypeDto {
    id?: number;
    name?: string | null;
    permissions?: { [key: string]: boolean; } | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

/* tslint:disable */

// ReSharper disable InconsistentNaming
export interface PagedResult<T> {
  items: T[];
  totalCount: number;
  pageSize: number;
  currentPage: number;
  totalPages: number;
}

export function isPagedResult<T>(result: unknown): result is PagedResult<T> {
  return (
    typeof result === 'object' &&
    result !== null &&
    Array.isArray((result as PagedResult<T>).items) &&
    typeof (result as PagedResult<T>).totalCount === 'number'
  )
}