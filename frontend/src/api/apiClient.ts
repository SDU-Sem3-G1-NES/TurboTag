//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ApiConfiguration {
  public baseUrl: string
  public instance: AxiosInstance

  constructor(baseUrl: string = 'https://localhost:7275', instance?: AxiosInstance) {
    this.baseUrl = baseUrl
    this.instance =
      instance ||
      axios.create({
        baseURL: baseUrl,
        headers: {
          'Content-Type': 'application/json'
        }
      })

    this.instance.interceptors.request.use(
      (config) => {
        // Add auth token if needed
        // const token = localStorage.getItem("authToken");
        // if (token) config.headers.Authorization = `Bearer ${token}`;
        return config
      },
      (error) => Promise.reject(error)
    )
  }
}

export class BaseApiClient {
  protected instance: AxiosInstance
  protected baseUrl: string

  constructor(configuration: ApiConfiguration) {
    this.baseUrl = configuration.baseUrl
    this.instance = configuration.instance
  }
}

export interface IAdminClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            getAllUsers(body?: UserFilter | undefined): Promise<PagedResult<UserDto> | UserDto[]>                    /**
             * @return OK
             */
            getAllContentLibraries(): Promise<PagedResult<LibraryDto> | LibraryDto[]>                    /**
             * @param userId (optional) 
             * @return OK
             */
            deleteUserById(userId?: number | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            deleteUsersById(body?: number[] | undefined): Promise<void>                    /**
             * @param userId (optional) 
             * @param body (optional) 
             * @return OK
             */
            updateUserById(userId?: number | undefined, body?: UserDto | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUsersById(body?: UserDto[] | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            createNewUser(body?: UserDto | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            createNewUsers(body?: UserDto[] | undefined): Promise<void>        }

    export class AdminClient extends BaseApiClient implements IAdminClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        getAllUsers(body?: UserFilter | undefined, cancelToken?: CancelToken): Promise<PagedResult<UserDto> | UserDto[]> {        let url_ = this.baseUrl + "/Admin/GetAllUsers";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllUsers(_response);
                });
        }

    protected processGetAllUsers(response: AxiosResponse): Promise<PagedResult<UserDto> | UserDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UserDto.fromJS(item));
        } else if (isPagedResult<UserDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UserDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UserDto> | UserDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UserDto> | UserDto[]>(null as any);
}
    

        /**
         * @return OK
         */
        getAllContentLibraries( cancelToken?: CancelToken): Promise<PagedResult<LibraryDto> | LibraryDto[]> {        let url_ = this.baseUrl + "/Admin/GetAllContentLibraries";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllContentLibraries(_response);
                });
        }

    protected processGetAllContentLibraries(response: AxiosResponse): Promise<PagedResult<LibraryDto> | LibraryDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(LibraryDto.fromJS(item));
        } else if (isPagedResult<LibraryDto>(resultData200)) {
            result200 = resultData200 as PagedResult<LibraryDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<LibraryDto> | LibraryDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<LibraryDto> | LibraryDto[]>(null as any);
}
    

        /**
         * @param userId (optional) 
         * @return OK
         */
        deleteUserById(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Admin/DeleteUserById?";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteUserById(_response);
                });
        }

    protected processDeleteUserById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        deleteUsersById(body?: number[] | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Admin/DeleteUsersById";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "DELETE",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteUsersById(_response);
                });
        }

    protected processDeleteUsersById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param userId (optional) 
         * @param body (optional) 
         * @return OK
         */
        updateUserById(userId?: number | undefined, body?: UserDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Admin/UpdateUserById?";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUserById(_response);
                });
        }

    protected processUpdateUserById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUsersById(body?: UserDto[] | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Admin/UpdateUsersById";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUsersById(_response);
                });
        }

    protected processUpdateUsersById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        createNewUser(body?: UserDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Admin/CreateNewUser";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCreateNewUser(_response);
                });
        }

    protected processCreateNewUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        createNewUsers(body?: UserDto[] | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Admin/CreateNewUsers";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCreateNewUsers(_response);
                });
        }

    protected processCreateNewUsers(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface IContentLibraryClient {
                    /**
             * @param userId (optional) 
             * @return OK
             */
            getUserLibrariesById(userId?: string | undefined): Promise<PagedResult<LibraryDto> | LibraryDto[]>                    /**
             * @param libraryId (optional) 
             * @return OK
             */
            getUserLibraryId(libraryId?: string | undefined): Promise<LibraryDto>                    /**
             * @param libraryId (optional) 
             * @return OK
             */
            getLibraryUploadsById(libraryId?: string | undefined): Promise<PagedResult<UploadDto> | UploadDto[]>                    /**
             * @param uploadId (optional) 
             * @return OK
             */
            getLibraryUploadById(uploadId?: string | undefined): Promise<UploadDto>        }

    export class ContentLibraryClient extends BaseApiClient implements IContentLibraryClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param userId (optional) 
         * @return OK
         */
        getUserLibrariesById(userId?: string | undefined, cancelToken?: CancelToken): Promise<PagedResult<LibraryDto> | LibraryDto[]> {        let url_ = this.baseUrl + "/ContentLibrary/GetUserLibrariesById?";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserLibrariesById(_response);
                });
        }

    protected processGetUserLibrariesById(response: AxiosResponse): Promise<PagedResult<LibraryDto> | LibraryDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(LibraryDto.fromJS(item));
        } else if (isPagedResult<LibraryDto>(resultData200)) {
            result200 = resultData200 as PagedResult<LibraryDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<LibraryDto> | LibraryDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<LibraryDto> | LibraryDto[]>(null as any);
}
    

        /**
         * @param libraryId (optional) 
         * @return OK
         */
        getUserLibraryId(libraryId?: string | undefined, cancelToken?: CancelToken): Promise<LibraryDto> {        let url_ = this.baseUrl + "/ContentLibrary/GetUserLibraryId?";
if (libraryId === null)
    throw new Error("The parameter 'libraryId' cannot be null.");
else if (libraryId !== undefined)
    url_ += "libraryId=" + encodeURIComponent("" + libraryId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserLibraryId(_response);
                });
        }

    protected processGetUserLibraryId(response: AxiosResponse): Promise<LibraryDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = LibraryDto.fromJS(resultData200);
        
        return Promise.resolve<LibraryDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<LibraryDto>(null as any);
}
    

        /**
         * @param libraryId (optional) 
         * @return OK
         */
        getLibraryUploadsById(libraryId?: string | undefined, cancelToken?: CancelToken): Promise<PagedResult<UploadDto> | UploadDto[]> {        let url_ = this.baseUrl + "/ContentLibrary/GetLibraryUploadsById?";
if (libraryId === null)
    throw new Error("The parameter 'libraryId' cannot be null.");
else if (libraryId !== undefined)
    url_ += "libraryId=" + encodeURIComponent("" + libraryId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "application/json"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLibraryUploadsById(_response);
                });
        }

    protected processGetLibraryUploadsById(response: AxiosResponse): Promise<PagedResult<UploadDto> | UploadDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(UploadDto.fromJS(item));
        } else if (isPagedResult<UploadDto>(resultData200)) {
            result200 = resultData200 as PagedResult<UploadDto>;
        } else {
            result200 = <any>null;
        }
        
        return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PagedResult<UploadDto> | UploadDto[]>(null as any);
}
    

        /**
         * @param uploadId (optional) 
         * @return OK
         */
        getLibraryUploadById(uploadId?: string | undefined, cancelToken?: CancelToken): Promise<UploadDto> {        let url_ = this.baseUrl + "/ContentLibrary/GetLibraryUploadById?";
if (uploadId === null)
    throw new Error("The parameter 'uploadId' cannot be null.");
else if (uploadId !== undefined)
    url_ += "uploadId=" + encodeURIComponent("" + uploadId) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLibraryUploadById(_response);
                });
        }

    protected processGetLibraryUploadById(response: AxiosResponse): Promise<UploadDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = UploadDto.fromJS(resultData200);
        
        return Promise.resolve<UploadDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<UploadDto>(null as any);
}
        }

            export interface ILoginClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            validateUserCredentials(body?: UserCredentialsDto | undefined): Promise<boolean>                    /**
             * @param email (optional) 
             * @return OK
             */
            getUserDataByEmail(email?: string | undefined): Promise<UserDto>        }

    export class LoginClient extends BaseApiClient implements ILoginClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        validateUserCredentials(body?: UserCredentialsDto | undefined, cancelToken?: CancelToken): Promise<boolean> {        let url_ = this.baseUrl + "/Login/ValidateUserCredentials";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "GET",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                            "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processValidateUserCredentials(_response);
                });
        }

    protected processValidateUserCredentials(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = resultData200 as boolean;
        
        return Promise.resolve<boolean>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}
    

        /**
         * @param email (optional) 
         * @return OK
         */
        getUserDataByEmail(email?: string | undefined, cancelToken?: CancelToken): Promise<UserDto> {        let url_ = this.baseUrl + "/Login/GetUserDataByEmail?";
if (email === null)
    throw new Error("The parameter 'email' cannot be null.");
else if (email !== undefined)
    url_ += "email=" + encodeURIComponent("" + email) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserDataByEmail(_response);
                });
        }

    protected processGetUserDataByEmail(response: AxiosResponse): Promise<UserDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = UserDto.fromJS(resultData200);
        
        return Promise.resolve<UserDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<UserDto>(null as any);
}
        }

            export interface IRegisterClient {
                    /**
             * @param email (optional) 
             * @return OK
             */
            checkIfUserExistsByEmail(email?: string | undefined): Promise<boolean>                    /**
             * @param body (optional) 
             * @return OK
             */
            registerUser(body?: UserCredentialsDto | undefined): Promise<void>        }

    export class RegisterClient extends BaseApiClient implements IRegisterClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param email (optional) 
         * @return OK
         */
        checkIfUserExistsByEmail(email?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {        let url_ = this.baseUrl + "/Register/CheckIfUserExistsByEmail?";
if (email === null)
    throw new Error("The parameter 'email' cannot be null.");
else if (email !== undefined)
    url_ += "email=" + encodeURIComponent("" + email) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCheckIfUserExistsByEmail(_response);
                });
        }

    protected processCheckIfUserExistsByEmail(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = resultData200 as boolean;
        
        return Promise.resolve<boolean>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        registerUser(body?: UserCredentialsDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Register/RegisterUser";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processRegisterUser(_response);
                });
        }

    protected processRegisterUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface ISettingsClient {
                    /**
             * @param id (optional) 
             * @return OK
             */
            getUserSettingsById(id?: number | undefined): Promise<SettingsDto>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUserSettingsById(body?: SettingsDto[] | undefined): Promise<void>                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUserSettingById(body?: SettingsDto | undefined): Promise<void>        }

    export class SettingsClient extends BaseApiClient implements ISettingsClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param id (optional) 
         * @return OK
         */
        getUserSettingsById(id?: number | undefined, cancelToken?: CancelToken): Promise<SettingsDto> {        let url_ = this.baseUrl + "/Settings/GetUserSettingsById?";
if (id === null)
    throw new Error("The parameter 'id' cannot be null.");
else if (id !== undefined)
    url_ += "id=" + encodeURIComponent("" + id) + "&";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserSettingsById(_response);
                });
        }

    protected processGetUserSettingsById(response: AxiosResponse): Promise<SettingsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = SettingsDto.fromJS(resultData200);
        
        return Promise.resolve<SettingsDto>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<SettingsDto>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUserSettingsById(body?: SettingsDto[] | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Settings/UpdateUserSettingsById";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUserSettingsById(_response);
                });
        }

    protected processUpdateUserSettingsById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUserSettingById(body?: SettingsDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Settings/UpdateUserSettingById";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUserSettingById(_response);
                });
        }

    protected processUpdateUserSettingById(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

            export interface ITestClient {
                    /**
             * @return OK
             */
            get(): Promise<string>        }

    export class TestClient extends BaseApiClient implements ITestClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @return OK
         */
        get( cancelToken?: CancelToken): Promise<string> {        let url_ = this.baseUrl + "/Test";
url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGet(_response);
                });
        }

    protected processGet(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                const _responseText = response.data;
        let result200: any = null;
        let resultData200 = _responseText;
                result200 = resultData200 as string;
        
        return Promise.resolve<string>(result200);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}
        }

            export interface IUploadClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            storeUpload(body?: UploadDto | undefined): Promise<void>        }

    export class UploadClient extends BaseApiClient implements IUploadClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        storeUpload(body?: UploadDto | undefined, cancelToken?: CancelToken): Promise<void> {        let url_ = this.baseUrl + "/Upload/StoreUpload";
url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json-patch+json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processStoreUpload(_response);
                });
        }

    protected processStoreUpload(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (const k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
                return Promise.resolve<void>(null as any);
        
    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
        }

export class LibraryDto implements ILibraryDto {
    id?: number;
    name?: string | null;

    constructor(data?: ILibraryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): LibraryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LibraryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ILibraryDto {
    id?: number;
    name?: string | null;
}

export class PagedResult_LibraryDto implements IPagedResult_LibraryDto {
    items?: LibraryDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_LibraryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LibraryDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_LibraryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_LibraryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_LibraryDto {
    items?: LibraryDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_UploadDto implements IPagedResult_UploadDto {
    items?: UploadDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_UploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UploadDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_UploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_UploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_UploadDto {
    items?: UploadDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class PagedResult_UserDto implements IPagedResult_UserDto {
    items?: UserDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;

    constructor(data?: IPagedResult_UserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResult_UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult_UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        return data;
    }
}

export interface IPagedResult_UserDto {
    items?: UserDto[];
    totalCount?: number;
    pageSize?: number;
    currentPage?: number;
    totalPages?: number;

    [key: string]: any;
}

export class SettingsDto implements ISettingsDto {
    id?: number;
    name?: string | null;
    value?: string | null;

    constructor(data?: ISettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): SettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface ISettingsDto {
    id?: number;
    name?: string | null;
    value?: string | null;
}

export class UploadDto implements IUploadDto {
    id?: number;
    ownerId?: number;
    date?: Date;
    type?: string | null;
    libraryId?: number;

    constructor(data?: IUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.libraryId = _data["libraryId"] !== undefined ? _data["libraryId"] : <any>null;
        }
    }

    static fromJS(data: any): UploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["libraryId"] = this.libraryId !== undefined ? this.libraryId : <any>null;
        return data;
    }
}

export interface IUploadDto {
    id?: number;
    ownerId?: number;
    date?: Date;
    type?: string | null;
    libraryId?: number;
}

export class UserCredentialsDto implements IUserCredentialsDto {
    email?: string | null;
    password?: string | null;

    constructor(data?: IUserCredentialsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UserCredentialsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserCredentialsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IUserCredentialsDto {
    email?: string | null;
    password?: string | null;
}

export class UserDto implements IUserDto {
    id?: number;
    userTypeId?: number;
    name?: string | null;
    email?: string | null;
    accessibleLibraryIds?: number[] | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userTypeId = _data["userTypeId"] !== undefined ? _data["userTypeId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            if (Array.isArray(_data["accessibleLibraryIds"])) {
                this.accessibleLibraryIds = [] as any;
                for (let item of _data["accessibleLibraryIds"])
                    this.accessibleLibraryIds!.push(item);
            }
            else {
                this.accessibleLibraryIds = <any>null;
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userTypeId"] = this.userTypeId !== undefined ? this.userTypeId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        if (Array.isArray(this.accessibleLibraryIds)) {
            data["accessibleLibraryIds"] = [];
            for (let item of this.accessibleLibraryIds)
                data["accessibleLibraryIds"].push(item);
        }
        return data;
    }
}

export interface IUserDto {
    id?: number;
    userTypeId?: number;
    name?: string | null;
    email?: string | null;
    accessibleLibraryIds?: number[] | null;
}

export class UserFilter implements IUserFilter {
    userIds?: number[] | null;
    userTypeIds?: number[] | null;
    name?: string | null;
    email?: string | null;
    libraryId?: number | null;
    pageNumber?: number | null;
    pageSize?: number | null;

    constructor(data?: IUserFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            else {
                this.userIds = <any>null;
            }
            if (Array.isArray(_data["userTypeIds"])) {
                this.userTypeIds = [] as any;
                for (let item of _data["userTypeIds"])
                    this.userTypeIds!.push(item);
            }
            else {
                this.userTypeIds = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.libraryId = _data["libraryId"] !== undefined ? _data["libraryId"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
        }
    }

    static fromJS(data: any): UserFilter {
        data = typeof data === 'object' ? data : {};
        let result = new UserFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        if (Array.isArray(this.userTypeIds)) {
            data["userTypeIds"] = [];
            for (let item of this.userTypeIds)
                data["userTypeIds"].push(item);
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["libraryId"] = this.libraryId !== undefined ? this.libraryId : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        return data;
    }
}

export interface IUserFilter {
    userIds?: number[] | null;
    userTypeIds?: number[] | null;
    name?: string | null;
    email?: string | null;
    libraryId?: number | null;
    pageNumber?: number | null;
    pageSize?: number | null;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

/* tslint:disable */

// ReSharper disable InconsistentNaming

export interface PagedResult<T> {
  items: T[];
  totalCount: number;
  pageSize: number;
  currentPage: number;
}

export function isPagedResult<T>(result: any): result is PagedResult<T> {
  return result && Array.isArray(result.items) && typeof result.totalCount === 'number'
}