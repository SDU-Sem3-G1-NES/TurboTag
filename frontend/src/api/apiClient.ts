//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ApiConfiguration {
  public baseUrl: string;
  public instance: AxiosInstance;

  constructor(baseUrl: string = 'https://localhost:7275', instance?: AxiosInstance) {
    this.baseUrl = baseUrl;
    this.instance =
      instance ||
      axios.create({
        baseURL: baseUrl,
        headers: {
          'Content-Type': 'application/json'
        }
      });

    this.instance.interceptors.request.use(
      (config) => {
        // Add auth token if needed
        // const token = localStorage.getItem("authToken");
        // if (token) config.headers.Authorization = `Bearer ${token}`;
        return config;
      },
      (error) => Promise.reject(error)
    );
  }
}

export class BaseApiClient {
  protected instance: AxiosInstance;
  protected baseUrl: string;

  constructor(configuration: ApiConfiguration) {
    this.baseUrl = configuration.baseUrl;
    this.instance = configuration.instance;
  }
}

export interface IAdminClient {
                    /**
             * @return OK
             */
            getAllUsers(): Promise<UserDto[]>;
                    /**
             * @return OK
             */
            getAllContentLibraries(): Promise<LibraryDto[]>;
                    /**
             * @param userId (optional) 
             * @return OK
             */
            deleteUserById(userId?: number | undefined): Promise<void>;
                    /**
             * @param body (optional) 
             * @return OK
             */
            deleteUsersById(body?: number[] | undefined): Promise<void>;
                    /**
             * @param userId (optional) 
             * @param body (optional) 
             * @return OK
             */
            updateUserById(userId?: number | undefined, body?: UserDto | undefined): Promise<void>;
                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUsersById(body?: UserDto[] | undefined): Promise<void>;
                    /**
             * @param body (optional) 
             * @return OK
             */
            createNewUser(body?: UserDto | undefined): Promise<void>;
                    /**
             * @param body (optional) 
             * @return OK
             */
            createNewUsers(body?: UserDto[] | undefined): Promise<void>;
        }

    export class AdminClient extends BaseApiClient implements IAdminClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @return OK
         */
        getAllUsers( cancelToken?: CancelToken): Promise<UserDto[]> {
        let url_ = this.baseUrl + "/Admin/GetAllUsers";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllUsers(_response);
                });
        }

        protected processGetAllUsers(response: AxiosResponse): Promise<UserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UserDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto[]>(null as any);
        }
    

        /**
         * @return OK
         */
        getAllContentLibraries( cancelToken?: CancelToken): Promise<LibraryDto[]> {
        let url_ = this.baseUrl + "/Admin/GetAllContentLibraries";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllContentLibraries(_response);
                });
        }

        protected processGetAllContentLibraries(response: AxiosResponse): Promise<LibraryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LibraryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LibraryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LibraryDto[]>(null as any);
        }
    

        /**
         * @param userId (optional) 
         * @return OK
         */
        deleteUserById(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Admin/DeleteUserById?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteUserById(_response);
                });
        }

        protected processDeleteUserById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param body (optional) 
         * @return OK
         */
        deleteUsersById(body?: number[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Admin/DeleteUsersById";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "DELETE",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteUsersById(_response);
                });
        }

        protected processDeleteUsersById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param userId (optional) 
         * @param body (optional) 
         * @return OK
         */
        updateUserById(userId?: number | undefined, body?: UserDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Admin/UpdateUserById?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUserById(_response);
                });
        }

        protected processUpdateUserById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUsersById(body?: UserDto[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Admin/UpdateUsersById";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUsersById(_response);
                });
        }

        protected processUpdateUsersById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param body (optional) 
         * @return OK
         */
        createNewUser(body?: UserDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Admin/CreateNewUser";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCreateNewUser(_response);
                });
        }

        protected processCreateNewUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param body (optional) 
         * @return OK
         */
        createNewUsers(body?: UserDto[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Admin/CreateNewUsers";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCreateNewUsers(_response);
                });
        }

        protected processCreateNewUsers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
        }

            export interface IContentLibraryClient {
                    /**
             * @param userId (optional) 
             * @return OK
             */
            getUserLibrariesById(userId?: string | undefined): Promise<LibraryDto[]>;
                    /**
             * @param libraryId (optional) 
             * @return OK
             */
            getUserLibraryId(libraryId?: string | undefined): Promise<LibraryDto>;
                    /**
             * @param libraryId (optional) 
             * @return OK
             */
            getLibraryUploadsById(libraryId?: string | undefined): Promise<UploadDto[]>;
                    /**
             * @param uploadId (optional) 
             * @return OK
             */
            getLibraryUploadById(uploadId?: string | undefined): Promise<UploadDto>;
        }

    export class ContentLibraryClient extends BaseApiClient implements IContentLibraryClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param userId (optional) 
         * @return OK
         */
        getUserLibrariesById(userId?: string | undefined, cancelToken?: CancelToken): Promise<LibraryDto[]> {
        let url_ = this.baseUrl + "/ContentLibrary/GetUserLibrariesById?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserLibrariesById(_response);
                });
        }

        protected processGetUserLibrariesById(response: AxiosResponse): Promise<LibraryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LibraryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LibraryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LibraryDto[]>(null as any);
        }
    

        /**
         * @param libraryId (optional) 
         * @return OK
         */
        getUserLibraryId(libraryId?: string | undefined, cancelToken?: CancelToken): Promise<LibraryDto> {
        let url_ = this.baseUrl + "/ContentLibrary/GetUserLibraryId?";
        if (libraryId === null)
            throw new Error("The parameter 'libraryId' cannot be null.");
        else if (libraryId !== undefined)
            url_ += "libraryId=" + encodeURIComponent("" + libraryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserLibraryId(_response);
                });
        }

        protected processGetUserLibraryId(response: AxiosResponse): Promise<LibraryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LibraryDto.fromJS(resultData200);
            return Promise.resolve<LibraryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LibraryDto>(null as any);
        }
    

        /**
         * @param libraryId (optional) 
         * @return OK
         */
        getLibraryUploadsById(libraryId?: string | undefined, cancelToken?: CancelToken): Promise<UploadDto[]> {
        let url_ = this.baseUrl + "/ContentLibrary/GetLibraryUploadsById?";
        if (libraryId === null)
            throw new Error("The parameter 'libraryId' cannot be null.");
        else if (libraryId !== undefined)
            url_ += "libraryId=" + encodeURIComponent("" + libraryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLibraryUploadsById(_response);
                });
        }

        protected processGetLibraryUploadsById(response: AxiosResponse): Promise<UploadDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UploadDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UploadDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UploadDto[]>(null as any);
        }
    

        /**
         * @param uploadId (optional) 
         * @return OK
         */
        getLibraryUploadById(uploadId?: string | undefined, cancelToken?: CancelToken): Promise<UploadDto> {
        let url_ = this.baseUrl + "/ContentLibrary/GetLibraryUploadById?";
        if (uploadId === null)
            throw new Error("The parameter 'uploadId' cannot be null.");
        else if (uploadId !== undefined)
            url_ += "uploadId=" + encodeURIComponent("" + uploadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLibraryUploadById(_response);
                });
        }

        protected processGetLibraryUploadById(response: AxiosResponse): Promise<UploadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UploadDto.fromJS(resultData200);
            return Promise.resolve<UploadDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UploadDto>(null as any);
        }
        }

            export interface IFileClient {
                    /**
             * @param file (optional) 
             * @return OK
             */
            uploadFile(file?: FileParameter | undefined): Promise<void>;
                    /**
             * @param id (optional) 
             * @return OK
             */
            getFileById(id?: string | undefined): Promise<void>;
                    /**
             * @param id (optional) 
             * @return OK
             */
            deleteFile(id?: string | undefined): Promise<void>;
        }

    export class FileClient extends BaseApiClient implements IFileClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param file (optional) 
         * @return OK
         */
        uploadFile(file?: FileParameter | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/File/UploadFile";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = new FormData();
            if (file === null || file === undefined)
                throw new Error("The parameter 'file' cannot be null.");
            else
                content_.append("file", file.data, file.fileName ? file.fileName : "file");

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUploadFile(_response);
                });
        }

        protected processUploadFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param id (optional) 
         * @return OK
         */
        getFileById(id?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/File/GetFileById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetFileById(_response);
                });
        }

        protected processGetFileById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param id (optional) 
         * @return OK
         */
        deleteFile(id?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/File/DeleteFile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteFile(_response);
                });
        }

        protected processDeleteFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
        }

            export interface ILessonClient {
                    /**
             * @return OK
             */
            getAllLessons(): Promise<void>;
                    /**
             * @param tags (optional) 
             * @return OK
             */
            getLessonsByTags(tags?: string[] | undefined): Promise<void>;
                    /**
             * @param title (optional) 
             * @return OK
             */
            getLessonsByTitle(title?: string | undefined): Promise<void>;
                    /**
             * @param lessonId (optional) 
             * @return OK
             */
            getLessonById(lessonId?: string | undefined): Promise<void>;
                    /**
             * @param objectId (optional) 
             * @return OK
             */
            getLessonByObjectId(objectId?: string | undefined): Promise<void>;
                    /**
             * @param uploadId (optional) 
             * @return OK
             */
            getLessonByUploadId(uploadId?: number | undefined): Promise<void>;
                    /**
             * @param body (optional) 
             * @return OK
             */
            addLesson(body?: LessonDto | undefined): Promise<void>;
                    /**
             * @param body (optional) 
             * @return OK
             */
            updateLesson(body?: LessonDto | undefined): Promise<void>;
                    /**
             * @param lessonId (optional) 
             * @return OK
             */
            deleteLessonById(lessonId?: number | undefined): Promise<void>;
                    /**
             * @param objectId (optional) 
             * @return OK
             */
            deleteLessonByObjectId(objectId?: string | undefined): Promise<void>;
        }

    export class LessonClient extends BaseApiClient implements ILessonClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @return OK
         */
        getAllLessons( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lesson/GetAllLessons";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetAllLessons(_response);
                });
        }

        protected processGetAllLessons(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param tags (optional) 
         * @return OK
         */
        getLessonsByTags(tags?: string[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lesson/GetLessonsByTags?";
        if (tags === null)
            throw new Error("The parameter 'tags' cannot be null.");
        else if (tags !== undefined)
            tags && tags.forEach(item => { url_ += "tags=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLessonsByTags(_response);
                });
        }

        protected processGetLessonsByTags(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param title (optional) 
         * @return OK
         */
        getLessonsByTitle(title?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lesson/GetLessonsByTitle?";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLessonsByTitle(_response);
                });
        }

        protected processGetLessonsByTitle(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param lessonId (optional) 
         * @return OK
         */
        getLessonById(lessonId?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lesson/GetLessonById?";
        if (lessonId === null)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else if (lessonId !== undefined)
            url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLessonById(_response);
                });
        }

        protected processGetLessonById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param objectId (optional) 
         * @return OK
         */
        getLessonByObjectId(objectId?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lesson/GetLessonByObjectId?";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLessonByObjectId(_response);
                });
        }

        protected processGetLessonByObjectId(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param uploadId (optional) 
         * @return OK
         */
        getLessonByUploadId(uploadId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lesson/GetLessonByUploadId?";
        if (uploadId === null)
            throw new Error("The parameter 'uploadId' cannot be null.");
        else if (uploadId !== undefined)
            url_ += "uploadId=" + encodeURIComponent("" + uploadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetLessonByUploadId(_response);
                });
        }

        protected processGetLessonByUploadId(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param body (optional) 
         * @return OK
         */
        addLesson(body?: LessonDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lesson/AddLesson";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processAddLesson(_response);
                });
        }

        protected processAddLesson(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateLesson(body?: LessonDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lesson/UpdateLesson";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateLesson(_response);
                });
        }

        protected processUpdateLesson(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param lessonId (optional) 
         * @return OK
         */
        deleteLessonById(lessonId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lesson/DeleteLessonById?";
        if (lessonId === null)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else if (lessonId !== undefined)
            url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteLessonById(_response);
                });
        }

        protected processDeleteLessonById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param objectId (optional) 
         * @return OK
         */
        deleteLessonByObjectId(objectId?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lesson/DeleteLessonByObjectId?";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "DELETE",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processDeleteLessonByObjectId(_response);
                });
        }

        protected processDeleteLessonByObjectId(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
        }

            export interface ILoginClient {
                    /**
             * @param body (optional) 
             * @return OK
             */
            validateUserCredentials(body?: UserCredentialsDto | undefined): Promise<boolean>;
                    /**
             * @param email (optional) 
             * @return OK
             */
            getUserDataByEmail(email?: string | undefined): Promise<UserDto>;
                    /**
             * @return OK
             */
            storeUserSession(): Promise<void>;
                    /**
             * @param sessionId (optional) 
             * @return OK
             */
            getUserDataBySessionId(sessionId?: string | undefined): Promise<void>;
        }

    export class LoginClient extends BaseApiClient implements ILoginClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param body (optional) 
         * @return OK
         */
        validateUserCredentials(body?: UserCredentialsDto | undefined, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/Login/ValidateUserCredentials";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "GET",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                            "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processValidateUserCredentials(_response);
                });
        }

        protected processValidateUserCredentials(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
        }
    

        /**
         * @param email (optional) 
         * @return OK
         */
        getUserDataByEmail(email?: string | undefined, cancelToken?: CancelToken): Promise<UserDto> {
        let url_ = this.baseUrl + "/Login/GetUserDataByEmail?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserDataByEmail(_response);
                });
        }

        protected processGetUserDataByEmail(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
        }
    

        /**
         * @return OK
         */
        storeUserSession( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Login/StoreUserSession";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "POST",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processStoreUserSession(_response);
                });
        }

        protected processStoreUserSession(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param sessionId (optional) 
         * @return OK
         */
        getUserDataBySessionId(sessionId?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Login/GetUserDataBySessionId?";
        if (sessionId === null)
            throw new Error("The parameter 'sessionId' cannot be null.");
        else if (sessionId !== undefined)
            url_ += "sessionId=" + encodeURIComponent("" + sessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserDataBySessionId(_response);
                });
        }

        protected processGetUserDataBySessionId(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
        }

            export interface IRegisterClient {
                    /**
             * @param email (optional) 
             * @return OK
             */
            checkIfUserExistsByEmail(email?: string | undefined): Promise<boolean>;
                    /**
             * @param body (optional) 
             * @return OK
             */
            registerUser(body?: UserCredentialsDto | undefined): Promise<void>;
        }

    export class RegisterClient extends BaseApiClient implements IRegisterClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param email (optional) 
         * @return OK
         */
        checkIfUserExistsByEmail(email?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/Register/CheckIfUserExistsByEmail?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processCheckIfUserExistsByEmail(_response);
                });
        }

        protected processCheckIfUserExistsByEmail(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
        }
    

        /**
         * @param body (optional) 
         * @return OK
         */
        registerUser(body?: UserCredentialsDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Register/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "POST",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processRegisterUser(_response);
                });
        }

        protected processRegisterUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
        }

            export interface ISettingsClient {
                    /**
             * @param id (optional) 
             * @return OK
             */
            getUserSettingsById(id?: number | undefined): Promise<SettingsDto>;
                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUserSettingsById(body?: SettingsDto[] | undefined): Promise<void>;
                    /**
             * @param body (optional) 
             * @return OK
             */
            updateUserSettingById(body?: SettingsDto | undefined): Promise<void>;
        }

    export class SettingsClient extends BaseApiClient implements ISettingsClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @param id (optional) 
         * @return OK
         */
        getUserSettingsById(id?: number | undefined, cancelToken?: CancelToken): Promise<SettingsDto> {
        let url_ = this.baseUrl + "/Settings/GetUserSettingsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGetUserSettingsById(_response);
                });
        }

        protected processGetUserSettingsById(response: AxiosResponse): Promise<SettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SettingsDto.fromJS(resultData200);
            return Promise.resolve<SettingsDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SettingsDto>(null as any);
        }
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUserSettingsById(body?: SettingsDto[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Settings/UpdateUserSettingsById";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUserSettingsById(_response);
                });
        }

        protected processUpdateUserSettingsById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
    

        /**
         * @param body (optional) 
         * @return OK
         */
        updateUserSettingById(body?: SettingsDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Settings/UpdateUserSettingById";
        url_ = url_.replace(/[?&]$/, "");

                    const content_ = JSON.stringify(body);

                let options_: AxiosRequestConfig = {
                    data: content_,
                        method: "PUT",
        url: url_,
        headers: {
                            "Content-Type": "application/json",
                        },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processUpdateUserSettingById(_response);
                });
        }

        protected processUpdateUserSettingById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
        }
        }

            export interface ITestClient {
                    /**
             * @return OK
             */
            get(): Promise<string>;
        }

    export class TestClient extends BaseApiClient implements ITestClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @return OK
         */
        get( cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/Test";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "GET",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processGet(_response);
                });
        }

        protected processGet(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
        }
        }

            export interface IUploadClient {
                    /**
             * @return OK
             */
            storeUpload(): Promise<string>;
        }

    export class UploadClient extends BaseApiClient implements IUploadClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(configuration: ApiConfiguration = new ApiConfiguration()) {

            super(configuration);

        }

    
    

        /**
         * @return OK
         */
        storeUpload( cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/Upload/StoreUpload";
        url_ = url_.replace(/[?&]$/, "");

                let options_: AxiosRequestConfig = {
                        method: "POST",
        url: url_,
        headers: {
                                    "Accept": "text/plain"
                },
            cancelToken
        };

                    return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
        return _error.response;
        } else {
        throw _error;
        }
        }).then((_response: AxiosResponse) => {
                    return this.processStoreUpload(_response);
                });
        }

        protected processStoreUpload(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
        }
        }

export class FileMetadataDto implements IFileMetadataDto {
    id?: number | null;
    fileType?: string | null;
    fileName?: string | null;
    fileSize?: number | null;
    duration?: number | null;
    date?: Date | null;
    checkSum?: string | null;

    constructor(data?: IFileMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.fileType = _data["fileType"] !== undefined ? _data["fileType"] : <any>null;
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
            this.fileSize = _data["fileSize"] !== undefined ? _data["fileSize"] : <any>null;
            this.duration = _data["duration"] !== undefined ? _data["duration"] : <any>null;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.checkSum = _data["checkSum"] !== undefined ? _data["checkSum"] : <any>null;
        }
    }

    static fromJS(data: any): FileMetadataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileMetadataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["fileType"] = this.fileType !== undefined ? this.fileType : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["fileSize"] = this.fileSize !== undefined ? this.fileSize : <any>null;
        data["duration"] = this.duration !== undefined ? this.duration : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["checkSum"] = this.checkSum !== undefined ? this.checkSum : <any>null;
        return data;
    }
}

export interface IFileMetadataDto {
    id?: number | null;
    fileType?: string | null;
    fileName?: string | null;
    fileSize?: number | null;
    duration?: number | null;
    date?: Date | null;
    checkSum?: string | null;
}

export class LessonDetailsDto implements ILessonDetailsDto {
    id?: number | null;
    title?: string | null;
    description?: string | null;
    tags?: string[] | null;

    constructor(data?: ILessonDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
        }
    }

    static fromJS(data: any): LessonDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ILessonDetailsDto {
    id?: number | null;
    title?: string | null;
    description?: string | null;
    tags?: string[] | null;
}

export class LessonDto implements ILessonDto {
    mongoId?: string | null;
    uploadId?: number[] | null;
    lessonDetails?: LessonDetailsDto;
    fileMetadata?: FileMetadataDto[] | null;
    ownerId?: number | null;

    constructor(data?: ILessonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mongoId = _data["mongoId"] !== undefined ? _data["mongoId"] : <any>null;
            if (Array.isArray(_data["uploadId"])) {
                this.uploadId = [] as any;
                for (let item of _data["uploadId"])
                    this.uploadId!.push(item);
            }
            else {
                this.uploadId = <any>null;
            }
            this.lessonDetails = _data["lessonDetails"] ? LessonDetailsDto.fromJS(_data["lessonDetails"]) : <any>null;
            if (Array.isArray(_data["fileMetadata"])) {
                this.fileMetadata = [] as any;
                for (let item of _data["fileMetadata"])
                    this.fileMetadata!.push(FileMetadataDto.fromJS(item));
            }
            else {
                this.fileMetadata = <any>null;
            }
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
        }
    }

    static fromJS(data: any): LessonDto {
        data = typeof data === 'object' ? data : {};
        let result = new LessonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mongoId"] = this.mongoId !== undefined ? this.mongoId : <any>null;
        if (Array.isArray(this.uploadId)) {
            data["uploadId"] = [];
            for (let item of this.uploadId)
                data["uploadId"].push(item);
        }
        data["lessonDetails"] = this.lessonDetails ? this.lessonDetails.toJSON() : <any>null;
        if (Array.isArray(this.fileMetadata)) {
            data["fileMetadata"] = [];
            for (let item of this.fileMetadata)
                data["fileMetadata"].push(item.toJSON());
        }
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        return data;
    }
}

export interface ILessonDto {
    mongoId?: string | null;
    uploadId?: number[] | null;
    lessonDetails?: LessonDetailsDto;
    fileMetadata?: FileMetadataDto[] | null;
    ownerId?: number | null;
}

export class LibraryDto implements ILibraryDto {
    id?: number;
    name?: string | null;

    constructor(data?: ILibraryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): LibraryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LibraryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ILibraryDto {
    id?: number;
    name?: string | null;
}

export class SettingsDto implements ISettingsDto {
    id?: number;
    name?: string | null;
    value?: string | null;

    constructor(data?: ISettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): SettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface ISettingsDto {
    id?: number;
    name?: string | null;
    value?: string | null;
}

export class UploadDetailsDto implements IUploadDetailsDto {
    id?: number;
    description?: string | null;
    title?: string | null;
    tags?: string[] | null;

    constructor(data?: IUploadDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
        }
    }

    static fromJS(data: any): UploadDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IUploadDetailsDto {
    id?: number;
    description?: string | null;
    title?: string | null;
    tags?: string[] | null;
}

export class UploadDto implements IUploadDto {
    id?: number;
    ownerId?: number;
    libraryId?: number;
    details?: UploadDetailsDto;
    fileMetadata?: FileMetadataDto;

    constructor(data?: IUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            this.libraryId = _data["libraryId"] !== undefined ? _data["libraryId"] : <any>null;
            this.details = _data["details"] ? UploadDetailsDto.fromJS(_data["details"]) : <any>null;
            this.fileMetadata = _data["fileMetadata"] ? FileMetadataDto.fromJS(_data["fileMetadata"]) : <any>null;
        }
    }

    static fromJS(data: any): UploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        data["libraryId"] = this.libraryId !== undefined ? this.libraryId : <any>null;
        data["details"] = this.details ? this.details.toJSON() : <any>null;
        data["fileMetadata"] = this.fileMetadata ? this.fileMetadata.toJSON() : <any>null;
        return data;
    }
}

export interface IUploadDto {
    id?: number;
    ownerId?: number;
    libraryId?: number;
    details?: UploadDetailsDto;
    fileMetadata?: FileMetadataDto;
}

export class UserCredentialsDto implements IUserCredentialsDto {
    email?: string | null;
    password?: string | null;

    constructor(data?: IUserCredentialsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UserCredentialsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserCredentialsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IUserCredentialsDto {
    email?: string | null;
    password?: string | null;
}

export class UserDto implements IUserDto {
    id?: number;
    type?: number;
    email?: string | null;
    permissions?: string[] | null;
    settings?: SettingsDto[] | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            else {
                this.permissions = <any>null;
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(SettingsDto.fromJS(item));
            }
            else {
                this.settings = <any>null;
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserDto {
    id?: number;
    type?: number;
    email?: string | null;
    permissions?: string[] | null;
    settings?: SettingsDto[] | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

/* tslint:disable */

// ReSharper disable InconsistentNaming